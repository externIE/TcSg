/* soapC.cpp
   Generated by gSOAP 2.8.16 from soapshop.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "StdAfx.h"
#include "soapH.h"
#pragma warning(disable : 4291)
SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.16 2013-12-05 08:24:40 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__ItemTypeEnum:
		return soap_in_ns1__ItemTypeEnum(soap, NULL, NULL, "ns1:ItemTypeEnum");
	case SOAP_TYPE_ns1__KindEnum:
		return soap_in_ns1__KindEnum(soap, NULL, NULL, "ns1:KindEnum");
	case SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo:
		return soap_in_ns1__ArrayOfAwardLotteryPrizeInfo(soap, NULL, NULL, "ns1:ArrayOfAwardLotteryPrizeInfo");
	case SOAP_TYPE_ns1__AwardLotteryPrizeInfo:
		return soap_in_ns1__AwardLotteryPrizeInfo(soap, NULL, NULL, "ns1:AwardLotteryPrizeInfo");
	case SOAP_TYPE_ns1__AwardInfo:
		return soap_in_ns1__AwardInfo(soap, NULL, NULL, "ns1:AwardInfo");
	case SOAP_TYPE_ns1__AwardItemInfo:
		return soap_in_ns1__AwardItemInfo(soap, NULL, NULL, "ns1:AwardItemInfo");
	case SOAP_TYPE_ns1__ArrayOfAwardItemInfo:
		return soap_in_ns1__ArrayOfAwardItemInfo(soap, NULL, NULL, "ns1:ArrayOfAwardItemInfo");
	case SOAP_TYPE_ns1__ItemInfo:
		return soap_in_ns1__ItemInfo(soap, NULL, NULL, "ns1:ItemInfo");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningListResponse:
		return soap_in_PointerTo_ns1__GetLotteryWinningListResponse(soap, NULL, NULL, "ns1:GetLotteryWinningListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningList:
		return soap_in_PointerTo_ns1__GetLotteryWinningList(soap, NULL, NULL, "ns1:GetLotteryWinningList");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningTopResponse:
		return soap_in_PointerTo_ns1__GetLotteryWinningTopResponse(soap, NULL, NULL, "ns1:GetLotteryWinningTopResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningTop:
		return soap_in_PointerTo_ns1__GetLotteryWinningTop(soap, NULL, NULL, "ns1:GetLotteryWinningTop");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryPrizeResponse:
		return soap_in_PointerTo_ns1__GetLotteryPrizeResponse(soap, NULL, NULL, "ns1:GetLotteryPrizeResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryPrize:
		return soap_in_PointerTo_ns1__GetLotteryPrize(soap, NULL, NULL, "ns1:GetLotteryPrize");
	case SOAP_TYPE_PointerTo_ns1__LotteryResponse:
		return soap_in_PointerTo_ns1__LotteryResponse(soap, NULL, NULL, "ns1:LotteryResponse");
	case SOAP_TYPE_PointerTo_ns1__Lottery:
		return soap_in_PointerTo_ns1__Lottery(soap, NULL, NULL, "ns1:Lottery");
	case SOAP_TYPE_PointerTo_ns1__GetAwardInfoResponse:
		return soap_in_PointerTo_ns1__GetAwardInfoResponse(soap, NULL, NULL, "ns1:GetAwardInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAwardInfo:
		return soap_in_PointerTo_ns1__GetAwardInfo(soap, NULL, NULL, "ns1:GetAwardInfo");
	case SOAP_TYPE_PointerTo_ns1__GetAwardItemResponse:
		return soap_in_PointerTo_ns1__GetAwardItemResponse(soap, NULL, NULL, "ns1:GetAwardItemResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAwardItem:
		return soap_in_PointerTo_ns1__GetAwardItem(soap, NULL, NULL, "ns1:GetAwardItem");
	case SOAP_TYPE_PointerTo_ns1__AwardItemResponse:
		return soap_in_PointerTo_ns1__AwardItemResponse(soap, NULL, NULL, "ns1:AwardItemResponse");
	case SOAP_TYPE_PointerTo_ns1__AwardItem:
		return soap_in_PointerTo_ns1__AwardItem(soap, NULL, NULL, "ns1:AwardItem");
	case SOAP_TYPE_PointerTo_ns1__GetClothingIDResponse:
		return soap_in_PointerTo_ns1__GetClothingIDResponse(soap, NULL, NULL, "ns1:GetClothingIDResponse");
	case SOAP_TYPE_PointerTo_ns1__GetClothingID:
		return soap_in_PointerTo_ns1__GetClothingID(soap, NULL, NULL, "ns1:GetClothingID");
	case SOAP_TYPE_PointerTo_ns1__GetItemValueResponse:
		return soap_in_PointerTo_ns1__GetItemValueResponse(soap, NULL, NULL, "ns1:GetItemValueResponse");
	case SOAP_TYPE_PointerTo_ns1__GetItemValue:
		return soap_in_PointerTo_ns1__GetItemValue(soap, NULL, NULL, "ns1:GetItemValue");
	case SOAP_TYPE_PointerTo_ns1__GetItemByItemIDResponse:
		return soap_in_PointerTo_ns1__GetItemByItemIDResponse(soap, NULL, NULL, "ns1:GetItemByItemIDResponse");
	case SOAP_TYPE_PointerTo_ns1__GetItemByItemID:
		return soap_in_PointerTo_ns1__GetItemByItemID(soap, NULL, NULL, "ns1:GetItemByItemID");
	case SOAP_TYPE_PointerTo_ns1__GetItemByCodeResponse:
		return soap_in_PointerTo_ns1__GetItemByCodeResponse(soap, NULL, NULL, "ns1:GetItemByCodeResponse");
	case SOAP_TYPE_PointerTo_ns1__GetItemByCode:
		return soap_in_PointerTo_ns1__GetItemByCode(soap, NULL, NULL, "ns1:GetItemByCode");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult:
		return soap_in_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, NULL, NULL, "ns1:GetLotteryWinningListResponse-GetLotteryWinningListResult");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult:
		return soap_in_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, NULL, NULL, "ns1:GetLotteryWinningTopResponse-GetLotteryWinningTopResult");
	case SOAP_TYPE_PointerTons1__ArrayOfAwardLotteryPrizeInfo:
		return soap_in_PointerTons1__ArrayOfAwardLotteryPrizeInfo(soap, NULL, NULL, "ns1:ArrayOfAwardLotteryPrizeInfo");
	case SOAP_TYPE_PointerTons1__AwardInfo:
		return soap_in_PointerTons1__AwardInfo(soap, NULL, NULL, "ns1:AwardInfo");
	case SOAP_TYPE_PointerTons1__ArrayOfAwardItemInfo:
		return soap_in_PointerTons1__ArrayOfAwardItemInfo(soap, NULL, NULL, "ns1:ArrayOfAwardItemInfo");
	case SOAP_TYPE_PointerTons1__ItemInfo:
		return soap_in_PointerTons1__ItemInfo(soap, NULL, NULL, "ns1:ItemInfo");
	case SOAP_TYPE_PointerToPointerTons1__AwardLotteryPrizeInfo:
		return soap_in_PointerToPointerTons1__AwardLotteryPrizeInfo(soap, NULL, NULL, "ns1:AwardLotteryPrizeInfo");
	case SOAP_TYPE_PointerTons1__AwardLotteryPrizeInfo:
		return soap_in_PointerTons1__AwardLotteryPrizeInfo(soap, NULL, NULL, "ns1:AwardLotteryPrizeInfo");
	case SOAP_TYPE_PointerToPointerTons1__AwardItemInfo:
		return soap_in_PointerToPointerTons1__AwardItemInfo(soap, NULL, NULL, "ns1:AwardItemInfo");
	case SOAP_TYPE_PointerTons1__AwardItemInfo:
		return soap_in_PointerTons1__AwardItemInfo(soap, NULL, NULL, "ns1:AwardItemInfo");
	case SOAP_TYPE_xsd__decimal:
	{	char **s;
		s = soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:ArrayOfAwardLotteryPrizeInfo"))
		{	*type = SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo;
			return soap_in_ns1__ArrayOfAwardLotteryPrizeInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AwardLotteryPrizeInfo"))
		{	*type = SOAP_TYPE_ns1__AwardLotteryPrizeInfo;
			return soap_in_ns1__AwardLotteryPrizeInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AwardInfo"))
		{	*type = SOAP_TYPE_ns1__AwardInfo;
			return soap_in_ns1__AwardInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AwardItemInfo"))
		{	*type = SOAP_TYPE_ns1__AwardItemInfo;
			return soap_in_ns1__AwardItemInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfAwardItemInfo"))
		{	*type = SOAP_TYPE_ns1__ArrayOfAwardItemInfo;
			return soap_in_ns1__ArrayOfAwardItemInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemInfo"))
		{	*type = SOAP_TYPE_ns1__ItemInfo;
			return soap_in_ns1__ItemInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemTypeEnum"))
		{	*type = SOAP_TYPE_ns1__ItemTypeEnum;
			return soap_in_ns1__ItemTypeEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:KindEnum"))
		{	*type = SOAP_TYPE_ns1__KindEnum;
			return soap_in_ns1__KindEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	char **s;
			*type = SOAP_TYPE_xsd__decimal;
			s = soap_in_xsd__decimal(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GetLotteryWinningListResponse-GetLotteryWinningListResult"))
		{	*type = SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult;
			return soap_in__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLotteryWinningTopResponse-GetLotteryWinningTopResult"))
		{	*type = SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult;
			return soap_in__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLotteryWinningListResponse"))
		{	*type = SOAP_TYPE__ns1__GetLotteryWinningListResponse;
			return soap_in__ns1__GetLotteryWinningListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLotteryWinningList"))
		{	*type = SOAP_TYPE__ns1__GetLotteryWinningList;
			return soap_in__ns1__GetLotteryWinningList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLotteryWinningTopResponse"))
		{	*type = SOAP_TYPE__ns1__GetLotteryWinningTopResponse;
			return soap_in__ns1__GetLotteryWinningTopResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLotteryWinningTop"))
		{	*type = SOAP_TYPE__ns1__GetLotteryWinningTop;
			return soap_in__ns1__GetLotteryWinningTop(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLotteryPrizeResponse"))
		{	*type = SOAP_TYPE__ns1__GetLotteryPrizeResponse;
			return soap_in__ns1__GetLotteryPrizeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLotteryPrize"))
		{	*type = SOAP_TYPE__ns1__GetLotteryPrize;
			return soap_in__ns1__GetLotteryPrize(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LotteryResponse"))
		{	*type = SOAP_TYPE__ns1__LotteryResponse;
			return soap_in__ns1__LotteryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Lottery"))
		{	*type = SOAP_TYPE__ns1__Lottery;
			return soap_in__ns1__Lottery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAwardInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetAwardInfoResponse;
			return soap_in__ns1__GetAwardInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAwardInfo"))
		{	*type = SOAP_TYPE__ns1__GetAwardInfo;
			return soap_in__ns1__GetAwardInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAwardItemResponse"))
		{	*type = SOAP_TYPE__ns1__GetAwardItemResponse;
			return soap_in__ns1__GetAwardItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAwardItem"))
		{	*type = SOAP_TYPE__ns1__GetAwardItem;
			return soap_in__ns1__GetAwardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AwardItemResponse"))
		{	*type = SOAP_TYPE__ns1__AwardItemResponse;
			return soap_in__ns1__AwardItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AwardItem"))
		{	*type = SOAP_TYPE__ns1__AwardItem;
			return soap_in__ns1__AwardItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetClothingIDResponse"))
		{	*type = SOAP_TYPE__ns1__GetClothingIDResponse;
			return soap_in__ns1__GetClothingIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetClothingID"))
		{	*type = SOAP_TYPE__ns1__GetClothingID;
			return soap_in__ns1__GetClothingID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetItemValueResponse"))
		{	*type = SOAP_TYPE__ns1__GetItemValueResponse;
			return soap_in__ns1__GetItemValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetItemValue"))
		{	*type = SOAP_TYPE__ns1__GetItemValue;
			return soap_in__ns1__GetItemValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetItemByItemIDResponse"))
		{	*type = SOAP_TYPE__ns1__GetItemByItemIDResponse;
			return soap_in__ns1__GetItemByItemIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetItemByItemID"))
		{	*type = SOAP_TYPE__ns1__GetItemByItemID;
			return soap_in__ns1__GetItemByItemID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetItemByCodeResponse"))
		{	*type = SOAP_TYPE__ns1__GetItemByCodeResponse;
			return soap_in__ns1__GetItemByCodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetItemByCode"))
		{	*type = SOAP_TYPE__ns1__GetItemByCode;
			return soap_in__ns1__GetItemByCode(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__ItemTypeEnum:
		return soap_out_ns1__ItemTypeEnum(soap, tag, id, (const enum ns1__ItemTypeEnum *)ptr, "ns1:ItemTypeEnum");
	case SOAP_TYPE_ns1__KindEnum:
		return soap_out_ns1__KindEnum(soap, tag, id, (const enum ns1__KindEnum *)ptr, "ns1:KindEnum");
	case SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult:
		return ((_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *)ptr)->soap_out(soap, "ns1:GetLotteryWinningListResponse-GetLotteryWinningListResult", id, NULL);
	case SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult:
		return ((_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *)ptr)->soap_out(soap, "ns1:GetLotteryWinningTopResponse-GetLotteryWinningTopResult", id, NULL);
	case SOAP_TYPE__ns1__GetLotteryWinningListResponse:
		return ((_ns1__GetLotteryWinningListResponse *)ptr)->soap_out(soap, "ns1:GetLotteryWinningListResponse", id, NULL);
	case SOAP_TYPE__ns1__GetLotteryWinningList:
		return ((_ns1__GetLotteryWinningList *)ptr)->soap_out(soap, "ns1:GetLotteryWinningList", id, NULL);
	case SOAP_TYPE__ns1__GetLotteryWinningTopResponse:
		return ((_ns1__GetLotteryWinningTopResponse *)ptr)->soap_out(soap, "ns1:GetLotteryWinningTopResponse", id, NULL);
	case SOAP_TYPE__ns1__GetLotteryWinningTop:
		return ((_ns1__GetLotteryWinningTop *)ptr)->soap_out(soap, "ns1:GetLotteryWinningTop", id, NULL);
	case SOAP_TYPE__ns1__GetLotteryPrizeResponse:
		return ((_ns1__GetLotteryPrizeResponse *)ptr)->soap_out(soap, "ns1:GetLotteryPrizeResponse", id, NULL);
	case SOAP_TYPE__ns1__GetLotteryPrize:
		return ((_ns1__GetLotteryPrize *)ptr)->soap_out(soap, "ns1:GetLotteryPrize", id, NULL);
	case SOAP_TYPE__ns1__LotteryResponse:
		return ((_ns1__LotteryResponse *)ptr)->soap_out(soap, "ns1:LotteryResponse", id, NULL);
	case SOAP_TYPE__ns1__Lottery:
		return ((_ns1__Lottery *)ptr)->soap_out(soap, "ns1:Lottery", id, NULL);
	case SOAP_TYPE__ns1__GetAwardInfoResponse:
		return ((_ns1__GetAwardInfoResponse *)ptr)->soap_out(soap, "ns1:GetAwardInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetAwardInfo:
		return ((_ns1__GetAwardInfo *)ptr)->soap_out(soap, "ns1:GetAwardInfo", id, NULL);
	case SOAP_TYPE__ns1__GetAwardItemResponse:
		return ((_ns1__GetAwardItemResponse *)ptr)->soap_out(soap, "ns1:GetAwardItemResponse", id, NULL);
	case SOAP_TYPE__ns1__GetAwardItem:
		return ((_ns1__GetAwardItem *)ptr)->soap_out(soap, "ns1:GetAwardItem", id, NULL);
	case SOAP_TYPE__ns1__AwardItemResponse:
		return ((_ns1__AwardItemResponse *)ptr)->soap_out(soap, "ns1:AwardItemResponse", id, NULL);
	case SOAP_TYPE__ns1__AwardItem:
		return ((_ns1__AwardItem *)ptr)->soap_out(soap, "ns1:AwardItem", id, NULL);
	case SOAP_TYPE__ns1__GetClothingIDResponse:
		return ((_ns1__GetClothingIDResponse *)ptr)->soap_out(soap, "ns1:GetClothingIDResponse", id, NULL);
	case SOAP_TYPE__ns1__GetClothingID:
		return ((_ns1__GetClothingID *)ptr)->soap_out(soap, "ns1:GetClothingID", id, NULL);
	case SOAP_TYPE__ns1__GetItemValueResponse:
		return ((_ns1__GetItemValueResponse *)ptr)->soap_out(soap, "ns1:GetItemValueResponse", id, NULL);
	case SOAP_TYPE__ns1__GetItemValue:
		return ((_ns1__GetItemValue *)ptr)->soap_out(soap, "ns1:GetItemValue", id, NULL);
	case SOAP_TYPE__ns1__GetItemByItemIDResponse:
		return ((_ns1__GetItemByItemIDResponse *)ptr)->soap_out(soap, "ns1:GetItemByItemIDResponse", id, NULL);
	case SOAP_TYPE__ns1__GetItemByItemID:
		return ((_ns1__GetItemByItemID *)ptr)->soap_out(soap, "ns1:GetItemByItemID", id, NULL);
	case SOAP_TYPE__ns1__GetItemByCodeResponse:
		return ((_ns1__GetItemByCodeResponse *)ptr)->soap_out(soap, "ns1:GetItemByCodeResponse", id, NULL);
	case SOAP_TYPE__ns1__GetItemByCode:
		return ((_ns1__GetItemByCode *)ptr)->soap_out(soap, "ns1:GetItemByCode", id, NULL);
	case SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo:
		return ((ns1__ArrayOfAwardLotteryPrizeInfo *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfAwardLotteryPrizeInfo");
	case SOAP_TYPE_ns1__AwardLotteryPrizeInfo:
		return ((ns1__AwardLotteryPrizeInfo *)ptr)->soap_out(soap, tag, id, "ns1:AwardLotteryPrizeInfo");
	case SOAP_TYPE_ns1__AwardInfo:
		return ((ns1__AwardInfo *)ptr)->soap_out(soap, tag, id, "ns1:AwardInfo");
	case SOAP_TYPE_ns1__AwardItemInfo:
		return ((ns1__AwardItemInfo *)ptr)->soap_out(soap, tag, id, "ns1:AwardItemInfo");
	case SOAP_TYPE_ns1__ArrayOfAwardItemInfo:
		return ((ns1__ArrayOfAwardItemInfo *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfAwardItemInfo");
	case SOAP_TYPE_ns1__ItemInfo:
		return ((ns1__ItemInfo *)ptr)->soap_out(soap, tag, id, "ns1:ItemInfo");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningListResponse:
		return soap_out_PointerTo_ns1__GetLotteryWinningListResponse(soap, tag, id, (_ns1__GetLotteryWinningListResponse *const*)ptr, "ns1:GetLotteryWinningListResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningList:
		return soap_out_PointerTo_ns1__GetLotteryWinningList(soap, tag, id, (_ns1__GetLotteryWinningList *const*)ptr, "ns1:GetLotteryWinningList");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningTopResponse:
		return soap_out_PointerTo_ns1__GetLotteryWinningTopResponse(soap, tag, id, (_ns1__GetLotteryWinningTopResponse *const*)ptr, "ns1:GetLotteryWinningTopResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningTop:
		return soap_out_PointerTo_ns1__GetLotteryWinningTop(soap, tag, id, (_ns1__GetLotteryWinningTop *const*)ptr, "ns1:GetLotteryWinningTop");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryPrizeResponse:
		return soap_out_PointerTo_ns1__GetLotteryPrizeResponse(soap, tag, id, (_ns1__GetLotteryPrizeResponse *const*)ptr, "ns1:GetLotteryPrizeResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryPrize:
		return soap_out_PointerTo_ns1__GetLotteryPrize(soap, tag, id, (_ns1__GetLotteryPrize *const*)ptr, "ns1:GetLotteryPrize");
	case SOAP_TYPE_PointerTo_ns1__LotteryResponse:
		return soap_out_PointerTo_ns1__LotteryResponse(soap, tag, id, (_ns1__LotteryResponse *const*)ptr, "ns1:LotteryResponse");
	case SOAP_TYPE_PointerTo_ns1__Lottery:
		return soap_out_PointerTo_ns1__Lottery(soap, tag, id, (_ns1__Lottery *const*)ptr, "ns1:Lottery");
	case SOAP_TYPE_PointerTo_ns1__GetAwardInfoResponse:
		return soap_out_PointerTo_ns1__GetAwardInfoResponse(soap, tag, id, (_ns1__GetAwardInfoResponse *const*)ptr, "ns1:GetAwardInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAwardInfo:
		return soap_out_PointerTo_ns1__GetAwardInfo(soap, tag, id, (_ns1__GetAwardInfo *const*)ptr, "ns1:GetAwardInfo");
	case SOAP_TYPE_PointerTo_ns1__GetAwardItemResponse:
		return soap_out_PointerTo_ns1__GetAwardItemResponse(soap, tag, id, (_ns1__GetAwardItemResponse *const*)ptr, "ns1:GetAwardItemResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAwardItem:
		return soap_out_PointerTo_ns1__GetAwardItem(soap, tag, id, (_ns1__GetAwardItem *const*)ptr, "ns1:GetAwardItem");
	case SOAP_TYPE_PointerTo_ns1__AwardItemResponse:
		return soap_out_PointerTo_ns1__AwardItemResponse(soap, tag, id, (_ns1__AwardItemResponse *const*)ptr, "ns1:AwardItemResponse");
	case SOAP_TYPE_PointerTo_ns1__AwardItem:
		return soap_out_PointerTo_ns1__AwardItem(soap, tag, id, (_ns1__AwardItem *const*)ptr, "ns1:AwardItem");
	case SOAP_TYPE_PointerTo_ns1__GetClothingIDResponse:
		return soap_out_PointerTo_ns1__GetClothingIDResponse(soap, tag, id, (_ns1__GetClothingIDResponse *const*)ptr, "ns1:GetClothingIDResponse");
	case SOAP_TYPE_PointerTo_ns1__GetClothingID:
		return soap_out_PointerTo_ns1__GetClothingID(soap, tag, id, (_ns1__GetClothingID *const*)ptr, "ns1:GetClothingID");
	case SOAP_TYPE_PointerTo_ns1__GetItemValueResponse:
		return soap_out_PointerTo_ns1__GetItemValueResponse(soap, tag, id, (_ns1__GetItemValueResponse *const*)ptr, "ns1:GetItemValueResponse");
	case SOAP_TYPE_PointerTo_ns1__GetItemValue:
		return soap_out_PointerTo_ns1__GetItemValue(soap, tag, id, (_ns1__GetItemValue *const*)ptr, "ns1:GetItemValue");
	case SOAP_TYPE_PointerTo_ns1__GetItemByItemIDResponse:
		return soap_out_PointerTo_ns1__GetItemByItemIDResponse(soap, tag, id, (_ns1__GetItemByItemIDResponse *const*)ptr, "ns1:GetItemByItemIDResponse");
	case SOAP_TYPE_PointerTo_ns1__GetItemByItemID:
		return soap_out_PointerTo_ns1__GetItemByItemID(soap, tag, id, (_ns1__GetItemByItemID *const*)ptr, "ns1:GetItemByItemID");
	case SOAP_TYPE_PointerTo_ns1__GetItemByCodeResponse:
		return soap_out_PointerTo_ns1__GetItemByCodeResponse(soap, tag, id, (_ns1__GetItemByCodeResponse *const*)ptr, "ns1:GetItemByCodeResponse");
	case SOAP_TYPE_PointerTo_ns1__GetItemByCode:
		return soap_out_PointerTo_ns1__GetItemByCode(soap, tag, id, (_ns1__GetItemByCode *const*)ptr, "ns1:GetItemByCode");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult:
		return soap_out_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, tag, id, (_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *const*)ptr, "ns1:GetLotteryWinningListResponse-GetLotteryWinningListResult");
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult:
		return soap_out_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, tag, id, (_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *const*)ptr, "ns1:GetLotteryWinningTopResponse-GetLotteryWinningTopResult");
	case SOAP_TYPE_PointerTons1__ArrayOfAwardLotteryPrizeInfo:
		return soap_out_PointerTons1__ArrayOfAwardLotteryPrizeInfo(soap, tag, id, (ns1__ArrayOfAwardLotteryPrizeInfo *const*)ptr, "ns1:ArrayOfAwardLotteryPrizeInfo");
	case SOAP_TYPE_PointerTons1__AwardInfo:
		return soap_out_PointerTons1__AwardInfo(soap, tag, id, (ns1__AwardInfo *const*)ptr, "ns1:AwardInfo");
	case SOAP_TYPE_PointerTons1__ArrayOfAwardItemInfo:
		return soap_out_PointerTons1__ArrayOfAwardItemInfo(soap, tag, id, (ns1__ArrayOfAwardItemInfo *const*)ptr, "ns1:ArrayOfAwardItemInfo");
	case SOAP_TYPE_PointerTons1__ItemInfo:
		return soap_out_PointerTons1__ItemInfo(soap, tag, id, (ns1__ItemInfo *const*)ptr, "ns1:ItemInfo");
	case SOAP_TYPE_PointerToPointerTons1__AwardLotteryPrizeInfo:
		return soap_out_PointerToPointerTons1__AwardLotteryPrizeInfo(soap, tag, id, (ns1__AwardLotteryPrizeInfo **const*)ptr, "ns1:AwardLotteryPrizeInfo");
	case SOAP_TYPE_PointerTons1__AwardLotteryPrizeInfo:
		return soap_out_PointerTons1__AwardLotteryPrizeInfo(soap, tag, id, (ns1__AwardLotteryPrizeInfo *const*)ptr, "ns1:AwardLotteryPrizeInfo");
	case SOAP_TYPE_PointerToPointerTons1__AwardItemInfo:
		return soap_out_PointerToPointerTons1__AwardItemInfo(soap, tag, id, (ns1__AwardItemInfo **const*)ptr, "ns1:AwardItemInfo");
	case SOAP_TYPE_PointerTons1__AwardItemInfo:
		return soap_out_PointerTons1__AwardItemInfo(soap, tag, id, (ns1__AwardItemInfo *const*)ptr, "ns1:AwardItemInfo");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:decimal");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult:
		((_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult:
		((_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLotteryWinningListResponse:
		((_ns1__GetLotteryWinningListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLotteryWinningList:
		((_ns1__GetLotteryWinningList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLotteryWinningTopResponse:
		((_ns1__GetLotteryWinningTopResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLotteryWinningTop:
		((_ns1__GetLotteryWinningTop *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLotteryPrizeResponse:
		((_ns1__GetLotteryPrizeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLotteryPrize:
		((_ns1__GetLotteryPrize *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LotteryResponse:
		((_ns1__LotteryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Lottery:
		((_ns1__Lottery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAwardInfoResponse:
		((_ns1__GetAwardInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAwardInfo:
		((_ns1__GetAwardInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAwardItemResponse:
		((_ns1__GetAwardItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAwardItem:
		((_ns1__GetAwardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AwardItemResponse:
		((_ns1__AwardItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AwardItem:
		((_ns1__AwardItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetClothingIDResponse:
		((_ns1__GetClothingIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetClothingID:
		((_ns1__GetClothingID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetItemValueResponse:
		((_ns1__GetItemValueResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetItemValue:
		((_ns1__GetItemValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetItemByItemIDResponse:
		((_ns1__GetItemByItemIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetItemByItemID:
		((_ns1__GetItemByItemID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetItemByCodeResponse:
		((_ns1__GetItemByCodeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetItemByCode:
		((_ns1__GetItemByCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo:
		((ns1__ArrayOfAwardLotteryPrizeInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AwardLotteryPrizeInfo:
		((ns1__AwardLotteryPrizeInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AwardInfo:
		((ns1__AwardInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AwardItemInfo:
		((ns1__AwardItemInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfAwardItemInfo:
		((ns1__ArrayOfAwardItemInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ItemInfo:
		((ns1__ItemInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__GetLotteryWinningList_:
		soap_serialize___ns1__GetLotteryWinningList_(soap, (const struct __ns1__GetLotteryWinningList_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLotteryWinningTop_:
		soap_serialize___ns1__GetLotteryWinningTop_(soap, (const struct __ns1__GetLotteryWinningTop_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLotteryPrize_:
		soap_serialize___ns1__GetLotteryPrize_(soap, (const struct __ns1__GetLotteryPrize_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Lottery_:
		soap_serialize___ns1__Lottery_(soap, (const struct __ns1__Lottery_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAwardInfo_:
		soap_serialize___ns1__GetAwardInfo_(soap, (const struct __ns1__GetAwardInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAwardItem_:
		soap_serialize___ns1__GetAwardItem_(soap, (const struct __ns1__GetAwardItem_ *)ptr);
		break;
	case SOAP_TYPE___ns1__AwardItem_:
		soap_serialize___ns1__AwardItem_(soap, (const struct __ns1__AwardItem_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetClothingID_:
		soap_serialize___ns1__GetClothingID_(soap, (const struct __ns1__GetClothingID_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetItemValue_:
		soap_serialize___ns1__GetItemValue_(soap, (const struct __ns1__GetItemValue_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetItemByItemID_:
		soap_serialize___ns1__GetItemByItemID_(soap, (const struct __ns1__GetItemByItemID_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetItemByCode_:
		soap_serialize___ns1__GetItemByCode_(soap, (const struct __ns1__GetItemByCode_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLotteryWinningList:
		soap_serialize___ns1__GetLotteryWinningList(soap, (const struct __ns1__GetLotteryWinningList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLotteryWinningTop:
		soap_serialize___ns1__GetLotteryWinningTop(soap, (const struct __ns1__GetLotteryWinningTop *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLotteryPrize:
		soap_serialize___ns1__GetLotteryPrize(soap, (const struct __ns1__GetLotteryPrize *)ptr);
		break;
	case SOAP_TYPE___ns1__Lottery:
		soap_serialize___ns1__Lottery(soap, (const struct __ns1__Lottery *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAwardInfo:
		soap_serialize___ns1__GetAwardInfo(soap, (const struct __ns1__GetAwardInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAwardItem:
		soap_serialize___ns1__GetAwardItem(soap, (const struct __ns1__GetAwardItem *)ptr);
		break;
	case SOAP_TYPE___ns1__AwardItem:
		soap_serialize___ns1__AwardItem(soap, (const struct __ns1__AwardItem *)ptr);
		break;
	case SOAP_TYPE___ns1__GetClothingID:
		soap_serialize___ns1__GetClothingID(soap, (const struct __ns1__GetClothingID *)ptr);
		break;
	case SOAP_TYPE___ns1__GetItemValue:
		soap_serialize___ns1__GetItemValue(soap, (const struct __ns1__GetItemValue *)ptr);
		break;
	case SOAP_TYPE___ns1__GetItemByItemID:
		soap_serialize___ns1__GetItemByItemID(soap, (const struct __ns1__GetItemByItemID *)ptr);
		break;
	case SOAP_TYPE___ns1__GetItemByCode:
		soap_serialize___ns1__GetItemByCode(soap, (const struct __ns1__GetItemByCode *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningListResponse:
		soap_serialize_PointerTo_ns1__GetLotteryWinningListResponse(soap, (_ns1__GetLotteryWinningListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningList:
		soap_serialize_PointerTo_ns1__GetLotteryWinningList(soap, (_ns1__GetLotteryWinningList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningTopResponse:
		soap_serialize_PointerTo_ns1__GetLotteryWinningTopResponse(soap, (_ns1__GetLotteryWinningTopResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningTop:
		soap_serialize_PointerTo_ns1__GetLotteryWinningTop(soap, (_ns1__GetLotteryWinningTop *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLotteryPrizeResponse:
		soap_serialize_PointerTo_ns1__GetLotteryPrizeResponse(soap, (_ns1__GetLotteryPrizeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLotteryPrize:
		soap_serialize_PointerTo_ns1__GetLotteryPrize(soap, (_ns1__GetLotteryPrize *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LotteryResponse:
		soap_serialize_PointerTo_ns1__LotteryResponse(soap, (_ns1__LotteryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Lottery:
		soap_serialize_PointerTo_ns1__Lottery(soap, (_ns1__Lottery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAwardInfoResponse:
		soap_serialize_PointerTo_ns1__GetAwardInfoResponse(soap, (_ns1__GetAwardInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAwardInfo:
		soap_serialize_PointerTo_ns1__GetAwardInfo(soap, (_ns1__GetAwardInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAwardItemResponse:
		soap_serialize_PointerTo_ns1__GetAwardItemResponse(soap, (_ns1__GetAwardItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAwardItem:
		soap_serialize_PointerTo_ns1__GetAwardItem(soap, (_ns1__GetAwardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AwardItemResponse:
		soap_serialize_PointerTo_ns1__AwardItemResponse(soap, (_ns1__AwardItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AwardItem:
		soap_serialize_PointerTo_ns1__AwardItem(soap, (_ns1__AwardItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetClothingIDResponse:
		soap_serialize_PointerTo_ns1__GetClothingIDResponse(soap, (_ns1__GetClothingIDResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetClothingID:
		soap_serialize_PointerTo_ns1__GetClothingID(soap, (_ns1__GetClothingID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetItemValueResponse:
		soap_serialize_PointerTo_ns1__GetItemValueResponse(soap, (_ns1__GetItemValueResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetItemValue:
		soap_serialize_PointerTo_ns1__GetItemValue(soap, (_ns1__GetItemValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetItemByItemIDResponse:
		soap_serialize_PointerTo_ns1__GetItemByItemIDResponse(soap, (_ns1__GetItemByItemIDResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetItemByItemID:
		soap_serialize_PointerTo_ns1__GetItemByItemID(soap, (_ns1__GetItemByItemID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetItemByCodeResponse:
		soap_serialize_PointerTo_ns1__GetItemByCodeResponse(soap, (_ns1__GetItemByCodeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetItemByCode:
		soap_serialize_PointerTo_ns1__GetItemByCode(soap, (_ns1__GetItemByCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult:
		soap_serialize_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, (_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult:
		soap_serialize_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, (_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfAwardLotteryPrizeInfo:
		soap_serialize_PointerTons1__ArrayOfAwardLotteryPrizeInfo(soap, (ns1__ArrayOfAwardLotteryPrizeInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AwardInfo:
		soap_serialize_PointerTons1__AwardInfo(soap, (ns1__AwardInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfAwardItemInfo:
		soap_serialize_PointerTons1__ArrayOfAwardItemInfo(soap, (ns1__ArrayOfAwardItemInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemInfo:
		soap_serialize_PointerTons1__ItemInfo(soap, (ns1__ItemInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AwardLotteryPrizeInfo:
		soap_serialize_PointerToPointerTons1__AwardLotteryPrizeInfo(soap, (ns1__AwardLotteryPrizeInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AwardLotteryPrizeInfo:
		soap_serialize_PointerTons1__AwardLotteryPrizeInfo(soap, (ns1__AwardLotteryPrizeInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AwardItemInfo:
		soap_serialize_PointerToPointerTons1__AwardItemInfo(soap, (ns1__AwardItemInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AwardItemInfo:
		soap_serialize_PointerTons1__AwardItemInfo(soap, (ns1__AwardItemInfo *const*)ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_ns1__ItemInfo:
		return (void*)soap_instantiate_ns1__ItemInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfAwardItemInfo:
		return (void*)soap_instantiate_ns1__ArrayOfAwardItemInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AwardItemInfo:
		return (void*)soap_instantiate_ns1__AwardItemInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AwardInfo:
		return (void*)soap_instantiate_ns1__AwardInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AwardLotteryPrizeInfo:
		return (void*)soap_instantiate_ns1__AwardLotteryPrizeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo:
		return (void*)soap_instantiate_ns1__ArrayOfAwardLotteryPrizeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetItemByCode:
		return (void*)soap_instantiate__ns1__GetItemByCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetItemByCodeResponse:
		return (void*)soap_instantiate__ns1__GetItemByCodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetItemByItemID:
		return (void*)soap_instantiate__ns1__GetItemByItemID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetItemByItemIDResponse:
		return (void*)soap_instantiate__ns1__GetItemByItemIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetItemValue:
		return (void*)soap_instantiate__ns1__GetItemValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetItemValueResponse:
		return (void*)soap_instantiate__ns1__GetItemValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetClothingID:
		return (void*)soap_instantiate__ns1__GetClothingID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetClothingIDResponse:
		return (void*)soap_instantiate__ns1__GetClothingIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AwardItem:
		return (void*)soap_instantiate__ns1__AwardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AwardItemResponse:
		return (void*)soap_instantiate__ns1__AwardItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAwardItem:
		return (void*)soap_instantiate__ns1__GetAwardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAwardItemResponse:
		return (void*)soap_instantiate__ns1__GetAwardItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAwardInfo:
		return (void*)soap_instantiate__ns1__GetAwardInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAwardInfoResponse:
		return (void*)soap_instantiate__ns1__GetAwardInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Lottery:
		return (void*)soap_instantiate__ns1__Lottery(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LotteryResponse:
		return (void*)soap_instantiate__ns1__LotteryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLotteryPrize:
		return (void*)soap_instantiate__ns1__GetLotteryPrize(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLotteryPrizeResponse:
		return (void*)soap_instantiate__ns1__GetLotteryPrizeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLotteryWinningTop:
		return (void*)soap_instantiate__ns1__GetLotteryWinningTop(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult:
		return (void*)soap_instantiate__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLotteryWinningTopResponse:
		return (void*)soap_instantiate__ns1__GetLotteryWinningTopResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLotteryWinningList:
		return (void*)soap_instantiate__ns1__GetLotteryWinningList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult:
		return (void*)soap_instantiate__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLotteryWinningListResponse:
		return (void*)soap_instantiate__ns1__GetLotteryWinningListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetItemByCode:
		return (void*)soap_instantiate___ns1__GetItemByCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetItemByItemID:
		return (void*)soap_instantiate___ns1__GetItemByItemID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetItemValue:
		return (void*)soap_instantiate___ns1__GetItemValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetClothingID:
		return (void*)soap_instantiate___ns1__GetClothingID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__AwardItem:
		return (void*)soap_instantiate___ns1__AwardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAwardItem:
		return (void*)soap_instantiate___ns1__GetAwardItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAwardInfo:
		return (void*)soap_instantiate___ns1__GetAwardInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Lottery:
		return (void*)soap_instantiate___ns1__Lottery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLotteryPrize:
		return (void*)soap_instantiate___ns1__GetLotteryPrize(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLotteryWinningTop:
		return (void*)soap_instantiate___ns1__GetLotteryWinningTop(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLotteryWinningList:
		return (void*)soap_instantiate___ns1__GetLotteryWinningList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetItemByCode_:
		return (void*)soap_instantiate___ns1__GetItemByCode_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetItemByItemID_:
		return (void*)soap_instantiate___ns1__GetItemByItemID_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetItemValue_:
		return (void*)soap_instantiate___ns1__GetItemValue_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetClothingID_:
		return (void*)soap_instantiate___ns1__GetClothingID_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__AwardItem_:
		return (void*)soap_instantiate___ns1__AwardItem_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAwardItem_:
		return (void*)soap_instantiate___ns1__GetAwardItem_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAwardInfo_:
		return (void*)soap_instantiate___ns1__GetAwardInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Lottery_:
		return (void*)soap_instantiate___ns1__Lottery_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLotteryPrize_:
		return (void*)soap_instantiate___ns1__GetLotteryPrize_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLotteryWinningTop_:
		return (void*)soap_instantiate___ns1__GetLotteryWinningTop_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLotteryWinningList_:
		return (void*)soap_instantiate___ns1__GetLotteryWinningList_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__ItemInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__ItemInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ItemInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfAwardItemInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfAwardItemInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfAwardItemInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__AwardItemInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__AwardItemInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__AwardItemInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__AwardInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__AwardInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__AwardInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__AwardLotteryPrizeInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__AwardLotteryPrizeInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__AwardLotteryPrizeInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__ArrayOfAwardLotteryPrizeInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ArrayOfAwardLotteryPrizeInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetItemByCode:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetItemByCode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetItemByCode*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetItemByCodeResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetItemByCodeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetItemByCodeResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetItemByItemID:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetItemByItemID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetItemByItemID*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetItemByItemIDResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetItemByItemIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetItemByItemIDResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetItemValue:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetItemValue*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetItemValue*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetItemValueResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetItemValueResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetItemValueResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetClothingID:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetClothingID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetClothingID*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetClothingIDResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetClothingIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetClothingIDResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AwardItem:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AwardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AwardItem*)p->ptr);
		break;
	case SOAP_TYPE__ns1__AwardItemResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__AwardItemResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__AwardItemResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAwardItem:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAwardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAwardItem*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAwardItemResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAwardItemResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAwardItemResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAwardInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAwardInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAwardInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAwardInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAwardInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAwardInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__Lottery:
		if (p->size < 0)
			SOAP_DELETE((_ns1__Lottery*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__Lottery*)p->ptr);
		break;
	case SOAP_TYPE__ns1__LotteryResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__LotteryResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__LotteryResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLotteryPrize:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLotteryPrize*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLotteryPrize*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLotteryPrizeResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLotteryPrizeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLotteryPrizeResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLotteryWinningTop:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLotteryWinningTop*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLotteryWinningTop*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLotteryWinningTopResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLotteryWinningTopResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLotteryWinningTopResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLotteryWinningList:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLotteryWinningList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLotteryWinningList*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLotteryWinningListResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLotteryWinningListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLotteryWinningListResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetItemByCode:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetItemByCode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetItemByCode*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetItemByItemID:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetItemByItemID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetItemByItemID*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetItemValue:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetItemValue*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetItemValue*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetClothingID:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetClothingID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetClothingID*)p->ptr);
		break;
	case SOAP_TYPE___ns1__AwardItem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__AwardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__AwardItem*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAwardItem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAwardItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAwardItem*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAwardInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAwardInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAwardInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__Lottery:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__Lottery*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__Lottery*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetLotteryPrize:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetLotteryPrize*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetLotteryPrize*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetLotteryWinningTop:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetLotteryWinningTop*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetLotteryWinningTop*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetLotteryWinningList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetLotteryWinningList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetLotteryWinningList*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetItemByCode_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetItemByCode_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetItemByCode_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetItemByItemID_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetItemByItemID_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetItemByItemID_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetItemValue_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetItemValue_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetItemValue_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetClothingID_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetClothingID_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetClothingID_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__AwardItem_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__AwardItem_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__AwardItem_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAwardItem_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAwardItem_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAwardItem_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAwardInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAwardInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAwardInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__Lottery_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__Lottery_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__Lottery_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetLotteryPrize_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetLotteryPrize_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetLotteryPrize_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetLotteryWinningTop_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetLotteryWinningTop_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetLotteryWinningTop_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetLotteryWinningList_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetLotteryWinningList_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetLotteryWinningList_*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ItemTypeEnum(struct soap *soap, enum ns1__ItemTypeEnum *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__ItemTypeEnum
	*a = SOAP_DEFAULT_ns1__ItemTypeEnum;
#else
	*a = (enum ns1__ItemTypeEnum)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__ItemTypeEnum[] =
{	{ (long)ns1__ItemTypeEnum__Props, "Props" },
	{ (long)ns1__ItemTypeEnum__Clothes, "Clothes" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ItemTypeEnum2s(struct soap *soap, enum ns1__ItemTypeEnum n)
{
	return soap_code_list(soap, soap_codes_ns1__ItemTypeEnum, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemTypeEnum(struct soap *soap, const char *tag, int id, const enum ns1__ItemTypeEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemTypeEnum), type) || soap_send(soap, soap_ns1__ItemTypeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ItemTypeEnum(struct soap *soap, const char *s, enum ns1__ItemTypeEnum *a)
{
	*a = (enum ns1__ItemTypeEnum)soap_code_bits(soap_codes_ns1__ItemTypeEnum, s);
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ItemTypeEnum * SOAP_FMAC4 soap_in_ns1__ItemTypeEnum(struct soap *soap, const char *tag, enum ns1__ItemTypeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ItemTypeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemTypeEnum, sizeof(enum ns1__ItemTypeEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__ItemTypeEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ItemTypeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ItemTypeEnum, 0, sizeof(enum ns1__ItemTypeEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ItemTypeEnum(struct soap *soap, const enum ns1__ItemTypeEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ItemTypeEnum);
	if (soap_out_ns1__ItemTypeEnum(soap, tag?tag:"ns1:ItemTypeEnum", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ItemTypeEnum * SOAP_FMAC4 soap_get_ns1__ItemTypeEnum(struct soap *soap, enum ns1__ItemTypeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemTypeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__KindEnum(struct soap *soap, enum ns1__KindEnum *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__KindEnum
	*a = SOAP_DEFAULT_ns1__KindEnum;
#else
	*a = (enum ns1__KindEnum)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__KindEnum[] =
{	{ (long)ns1__KindEnum__Goods, "Goods" },
	{ (long)ns1__KindEnum__NotForSale, "NotForSale" },
	{ (long)ns1__KindEnum__Gift, "Gift" },
	{ (long)ns1__KindEnum__Complex, "Complex" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__KindEnum2s(struct soap *soap, enum ns1__KindEnum n)
{
	return soap_code_list(soap, soap_codes_ns1__KindEnum, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__KindEnum(struct soap *soap, const char *tag, int id, const enum ns1__KindEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__KindEnum), type) || soap_send(soap, soap_ns1__KindEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__KindEnum(struct soap *soap, const char *s, enum ns1__KindEnum *a)
{
	*a = (enum ns1__KindEnum)soap_code_bits(soap_codes_ns1__KindEnum, s);
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__KindEnum * SOAP_FMAC4 soap_in_ns1__KindEnum(struct soap *soap, const char *tag, enum ns1__KindEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__KindEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__KindEnum, sizeof(enum ns1__KindEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__KindEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__KindEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__KindEnum, 0, sizeof(enum ns1__KindEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__KindEnum(struct soap *soap, const enum ns1__KindEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__KindEnum);
	if (soap_out_ns1__KindEnum(soap, tag?tag:"ns1:KindEnum", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__KindEnum * SOAP_FMAC4 soap_get_ns1__KindEnum(struct soap *soap, enum ns1__KindEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__KindEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__size = 0;
	this->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any = NULL;
	this->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any_ = NULL;
}

void _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(struct soap *soap, const char *tag, int id, const _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult), type))
		return soap->error;
	if (a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any)
	{	int i;
		for (i = 0; i < a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any + i, ""))
				return soap->error;
	}
	soap_outliteral(soap, "-any", &(a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any_), NULL);
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult * SOAP_FMAC4 soap_in__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(struct soap *soap, const char *tag, _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult, sizeof(_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___any1 = NULL;
	size_t soap_flag___any_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any);
				}
				if (soap_in_byte(soap, "-any", a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any, "xsd:byte"))
				{	a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__size++;
					a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any = NULL;
					continue;
				}
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &(a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any_)))
				{	soap_flag___any_1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__size)
			a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult, 0, sizeof(_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult), 0, soap_copy__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult);
	if (this->soap_out(soap, tag?tag:"ns1:GetLotteryWinningListResponse-GetLotteryWinningListResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult * SOAP_FMAC4 soap_get__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(struct soap *soap, _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult * SOAP_FMAC2 soap_instantiate__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult);
		if (size)
			*size = sizeof(_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult, n);
		if (size)
			*size = n * sizeof(_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult %p -> %p\n", q, p));
	*(_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult*)p = *(_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult*)q;
}

void _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__size = 0;
	this->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any = NULL;
	this->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any_ = NULL;
}

void _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(struct soap *soap, const char *tag, int id, const _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult), type))
		return soap->error;
	if (a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any)
	{	int i;
		for (i = 0; i < a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any + i, ""))
				return soap->error;
	}
	soap_outliteral(soap, "-any", &(a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any_), NULL);
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult * SOAP_FMAC4 soap_in__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(struct soap *soap, const char *tag, _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult, sizeof(_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___any1 = NULL;
	size_t soap_flag___any_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any);
				}
				if (soap_in_byte(soap, "-any", a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any, "xsd:byte"))
				{	a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__size++;
					a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any = NULL;
					continue;
				}
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &(a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any_)))
				{	soap_flag___any_1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__size)
			a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult, 0, sizeof(_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult), 0, soap_copy__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult);
	if (this->soap_out(soap, tag?tag:"ns1:GetLotteryWinningTopResponse-GetLotteryWinningTopResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult * SOAP_FMAC4 soap_get__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(struct soap *soap, _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult * SOAP_FMAC2 soap_instantiate__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult);
		if (size)
			*size = sizeof(_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult, n);
		if (size)
			*size = n * sizeof(_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult %p -> %p\n", q, p));
	*(_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult*)p = *(_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult*)q;
}

void _ns1__GetLotteryWinningListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLotteryWinningListResponse::GetLotteryWinningListResult = NULL;
	soap_default_int(soap, &this->_ns1__GetLotteryWinningListResponse::recordCount);
	soap_default_string(soap, &this->_ns1__GetLotteryWinningListResponse::msg);
	/* transient soap skipped */
}

void _ns1__GetLotteryWinningListResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, &this->_ns1__GetLotteryWinningListResponse::GetLotteryWinningListResult);
	soap_serialize_string(soap, &this->_ns1__GetLotteryWinningListResponse::msg);
	/* transient soap skipped */
#endif
}

int _ns1__GetLotteryWinningListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLotteryWinningListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLotteryWinningListResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLotteryWinningListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLotteryWinningListResponse), type))
		return soap->error;
	if (a->GetLotteryWinningListResult)
		soap_element_result(soap, "ns1:GetLotteryWinningListResult");
	if (soap_out_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, "ns1:GetLotteryWinningListResult", -1, &(a->_ns1__GetLotteryWinningListResponse::GetLotteryWinningListResult), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:recordCount", -1, &(a->_ns1__GetLotteryWinningListResponse::recordCount), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:msg", -1, &(a->_ns1__GetLotteryWinningListResponse::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLotteryWinningListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLotteryWinningListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningListResponse * SOAP_FMAC4 soap_in__ns1__GetLotteryWinningListResponse(struct soap *soap, const char *tag, _ns1__GetLotteryWinningListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLotteryWinningListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLotteryWinningListResponse, sizeof(_ns1__GetLotteryWinningListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLotteryWinningListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLotteryWinningListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetLotteryWinningListResult1 = 1;
	size_t soap_flag_recordCount1 = 1;
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLotteryWinningListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, "ns1:GetLotteryWinningListResult", &(a->_ns1__GetLotteryWinningListResponse::GetLotteryWinningListResult), ""))
				{	soap_flag_GetLotteryWinningListResult1--;
					continue;
				}
			if (soap_flag_recordCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:recordCount", &(a->_ns1__GetLotteryWinningListResponse::recordCount), "xsd:int"))
				{	soap_flag_recordCount1--;
					continue;
				}
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:msg", &(a->_ns1__GetLotteryWinningListResponse::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetLotteryWinningListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLotteryWinningListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLotteryWinningListResponse, 0, sizeof(_ns1__GetLotteryWinningListResponse), 0, soap_copy__ns1__GetLotteryWinningListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetLotteryWinningListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetLotteryWinningListResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetLotteryWinningListResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLotteryWinningListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLotteryWinningListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningListResponse * SOAP_FMAC4 soap_get__ns1__GetLotteryWinningListResponse(struct soap *soap, _ns1__GetLotteryWinningListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLotteryWinningListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLotteryWinningListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLotteryWinningListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLotteryWinningListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLotteryWinningListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLotteryWinningListResponse);
		if (size)
			*size = sizeof(_ns1__GetLotteryWinningListResponse);
		((_ns1__GetLotteryWinningListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetLotteryWinningListResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetLotteryWinningListResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetLotteryWinningListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetLotteryWinningListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLotteryWinningListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLotteryWinningListResponse %p -> %p\n", q, p));
	*(_ns1__GetLotteryWinningListResponse*)p = *(_ns1__GetLotteryWinningListResponse*)q;
}

void _ns1__GetLotteryWinningList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetLotteryWinningList::appCode);
	soap_default_string(soap, &this->_ns1__GetLotteryWinningList::accessKey);
	soap_default_string(soap, &this->_ns1__GetLotteryWinningList::awardGuid);
	soap_default_int(soap, &this->_ns1__GetLotteryWinningList::pageIndex);
	soap_default_int(soap, &this->_ns1__GetLotteryWinningList::pageSize);
	soap_default_int(soap, &this->_ns1__GetLotteryWinningList::prizeID);
	soap_default_int(soap, &this->_ns1__GetLotteryWinningList::rounds);
	soap_default_time(soap, &this->_ns1__GetLotteryWinningList::dtBegin);
	soap_default_time(soap, &this->_ns1__GetLotteryWinningList::dtEnd);
	soap_default_string(soap, &this->_ns1__GetLotteryWinningList::username);
	soap_default_string(soap, &this->_ns1__GetLotteryWinningList::credential);
	/* transient soap skipped */
}

void _ns1__GetLotteryWinningList::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetLotteryWinningList::appCode);
	soap_serialize_string(soap, &this->_ns1__GetLotteryWinningList::accessKey);
	soap_serialize_string(soap, &this->_ns1__GetLotteryWinningList::awardGuid);
	soap_serialize_string(soap, &this->_ns1__GetLotteryWinningList::username);
	soap_serialize_string(soap, &this->_ns1__GetLotteryWinningList::credential);
	/* transient soap skipped */
#endif
}

int _ns1__GetLotteryWinningList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLotteryWinningList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLotteryWinningList(struct soap *soap, const char *tag, int id, const _ns1__GetLotteryWinningList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLotteryWinningList), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:appCode", -1, &(a->_ns1__GetLotteryWinningList::appCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:accessKey", -1, &(a->_ns1__GetLotteryWinningList::accessKey), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:awardGuid", -1, &(a->_ns1__GetLotteryWinningList::awardGuid), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:pageIndex", -1, &(a->_ns1__GetLotteryWinningList::pageIndex), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:pageSize", -1, &(a->_ns1__GetLotteryWinningList::pageSize), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:prizeID", -1, &(a->_ns1__GetLotteryWinningList::prizeID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:rounds", -1, &(a->_ns1__GetLotteryWinningList::rounds), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:dtBegin", -1, &(a->_ns1__GetLotteryWinningList::dtBegin), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:dtEnd", -1, &(a->_ns1__GetLotteryWinningList::dtEnd), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:username", -1, &(a->_ns1__GetLotteryWinningList::username), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:credential", -1, &(a->_ns1__GetLotteryWinningList::credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLotteryWinningList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLotteryWinningList(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningList * SOAP_FMAC4 soap_in__ns1__GetLotteryWinningList(struct soap *soap, const char *tag, _ns1__GetLotteryWinningList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLotteryWinningList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLotteryWinningList, sizeof(_ns1__GetLotteryWinningList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLotteryWinningList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLotteryWinningList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_appCode1 = 1;
	size_t soap_flag_accessKey1 = 1;
	size_t soap_flag_awardGuid1 = 1;
	size_t soap_flag_pageIndex1 = 1;
	size_t soap_flag_pageSize1 = 1;
	size_t soap_flag_prizeID1 = 1;
	size_t soap_flag_rounds1 = 1;
	size_t soap_flag_dtBegin1 = 1;
	size_t soap_flag_dtEnd1 = 1;
	size_t soap_flag_username1 = 1;
	size_t soap_flag_credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_appCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:appCode", &(a->_ns1__GetLotteryWinningList::appCode), "xsd:string"))
				{	soap_flag_appCode1--;
					continue;
				}
			if (soap_flag_accessKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:accessKey", &(a->_ns1__GetLotteryWinningList::accessKey), "xsd:string"))
				{	soap_flag_accessKey1--;
					continue;
				}
			if (soap_flag_awardGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:awardGuid", &(a->_ns1__GetLotteryWinningList::awardGuid), "xsd:string"))
				{	soap_flag_awardGuid1--;
					continue;
				}
			if (soap_flag_pageIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:pageIndex", &(a->_ns1__GetLotteryWinningList::pageIndex), "xsd:int"))
				{	soap_flag_pageIndex1--;
					continue;
				}
			if (soap_flag_pageSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:pageSize", &(a->_ns1__GetLotteryWinningList::pageSize), "xsd:int"))
				{	soap_flag_pageSize1--;
					continue;
				}
			if (soap_flag_prizeID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:prizeID", &(a->_ns1__GetLotteryWinningList::prizeID), "xsd:int"))
				{	soap_flag_prizeID1--;
					continue;
				}
			if (soap_flag_rounds1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:rounds", &(a->_ns1__GetLotteryWinningList::rounds), "xsd:int"))
				{	soap_flag_rounds1--;
					continue;
				}
			if (soap_flag_dtBegin1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:dtBegin", &(a->_ns1__GetLotteryWinningList::dtBegin), "xsd:dateTime"))
				{	soap_flag_dtBegin1--;
					continue;
				}
			if (soap_flag_dtEnd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:dtEnd", &(a->_ns1__GetLotteryWinningList::dtEnd), "xsd:dateTime"))
				{	soap_flag_dtEnd1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:username", &(a->_ns1__GetLotteryWinningList::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:credential", &(a->_ns1__GetLotteryWinningList::credential), "xsd:string"))
				{	soap_flag_credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLotteryWinningList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLotteryWinningList, 0, sizeof(_ns1__GetLotteryWinningList), 0, soap_copy__ns1__GetLotteryWinningList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pageIndex1 > 0 || soap_flag_pageSize1 > 0 || soap_flag_prizeID1 > 0 || soap_flag_rounds1 > 0 || soap_flag_dtBegin1 > 0 || soap_flag_dtEnd1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetLotteryWinningList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetLotteryWinningList);
	if (this->soap_out(soap, tag?tag:"ns1:GetLotteryWinningList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLotteryWinningList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLotteryWinningList(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningList * SOAP_FMAC4 soap_get__ns1__GetLotteryWinningList(struct soap *soap, _ns1__GetLotteryWinningList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLotteryWinningList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLotteryWinningList * SOAP_FMAC2 soap_instantiate__ns1__GetLotteryWinningList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLotteryWinningList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLotteryWinningList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLotteryWinningList);
		if (size)
			*size = sizeof(_ns1__GetLotteryWinningList);
		((_ns1__GetLotteryWinningList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetLotteryWinningList, n);
		if (size)
			*size = n * sizeof(_ns1__GetLotteryWinningList);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetLotteryWinningList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetLotteryWinningList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLotteryWinningList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLotteryWinningList %p -> %p\n", q, p));
	*(_ns1__GetLotteryWinningList*)p = *(_ns1__GetLotteryWinningList*)q;
}

void _ns1__GetLotteryWinningTopResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLotteryWinningTopResponse::GetLotteryWinningTopResult = NULL;
	soap_default_string(soap, &this->_ns1__GetLotteryWinningTopResponse::msg);
	/* transient soap skipped */
}

void _ns1__GetLotteryWinningTopResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, &this->_ns1__GetLotteryWinningTopResponse::GetLotteryWinningTopResult);
	soap_serialize_string(soap, &this->_ns1__GetLotteryWinningTopResponse::msg);
	/* transient soap skipped */
#endif
}

int _ns1__GetLotteryWinningTopResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLotteryWinningTopResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLotteryWinningTopResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLotteryWinningTopResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLotteryWinningTopResponse), type))
		return soap->error;
	if (a->GetLotteryWinningTopResult)
		soap_element_result(soap, "ns1:GetLotteryWinningTopResult");
	if (soap_out_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, "ns1:GetLotteryWinningTopResult", -1, &(a->_ns1__GetLotteryWinningTopResponse::GetLotteryWinningTopResult), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:msg", -1, &(a->_ns1__GetLotteryWinningTopResponse::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLotteryWinningTopResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLotteryWinningTopResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningTopResponse * SOAP_FMAC4 soap_in__ns1__GetLotteryWinningTopResponse(struct soap *soap, const char *tag, _ns1__GetLotteryWinningTopResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLotteryWinningTopResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLotteryWinningTopResponse, sizeof(_ns1__GetLotteryWinningTopResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLotteryWinningTopResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLotteryWinningTopResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetLotteryWinningTopResult1 = 1;
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLotteryWinningTopResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, "ns1:GetLotteryWinningTopResult", &(a->_ns1__GetLotteryWinningTopResponse::GetLotteryWinningTopResult), ""))
				{	soap_flag_GetLotteryWinningTopResult1--;
					continue;
				}
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:msg", &(a->_ns1__GetLotteryWinningTopResponse::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetLotteryWinningTopResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLotteryWinningTopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLotteryWinningTopResponse, 0, sizeof(_ns1__GetLotteryWinningTopResponse), 0, soap_copy__ns1__GetLotteryWinningTopResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetLotteryWinningTopResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetLotteryWinningTopResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetLotteryWinningTopResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLotteryWinningTopResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLotteryWinningTopResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningTopResponse * SOAP_FMAC4 soap_get__ns1__GetLotteryWinningTopResponse(struct soap *soap, _ns1__GetLotteryWinningTopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLotteryWinningTopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLotteryWinningTopResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLotteryWinningTopResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLotteryWinningTopResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLotteryWinningTopResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLotteryWinningTopResponse);
		if (size)
			*size = sizeof(_ns1__GetLotteryWinningTopResponse);
		((_ns1__GetLotteryWinningTopResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetLotteryWinningTopResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetLotteryWinningTopResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetLotteryWinningTopResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetLotteryWinningTopResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLotteryWinningTopResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLotteryWinningTopResponse %p -> %p\n", q, p));
	*(_ns1__GetLotteryWinningTopResponse*)p = *(_ns1__GetLotteryWinningTopResponse*)q;
}

void _ns1__GetLotteryWinningTop::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetLotteryWinningTop::appCode);
	soap_default_string(soap, &this->_ns1__GetLotteryWinningTop::accessKey);
	soap_default_string(soap, &this->_ns1__GetLotteryWinningTop::awardGuid);
	soap_default_int(soap, &this->_ns1__GetLotteryWinningTop::top);
	soap_default_string(soap, &this->_ns1__GetLotteryWinningTop::prizeIndex);
	soap_default_string(soap, &this->_ns1__GetLotteryWinningTop::prizeID);
	soap_default_xsd__decimal(soap, &this->_ns1__GetLotteryWinningTop::prizeValue);
	soap_default_time(soap, &this->_ns1__GetLotteryWinningTop::dtBegin);
	soap_default_time(soap, &this->_ns1__GetLotteryWinningTop::dtEnd);
	/* transient soap skipped */
}

void _ns1__GetLotteryWinningTop::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetLotteryWinningTop::appCode);
	soap_serialize_string(soap, &this->_ns1__GetLotteryWinningTop::accessKey);
	soap_serialize_string(soap, &this->_ns1__GetLotteryWinningTop::awardGuid);
	soap_serialize_string(soap, &this->_ns1__GetLotteryWinningTop::prizeIndex);
	soap_serialize_string(soap, &this->_ns1__GetLotteryWinningTop::prizeID);
	soap_serialize_xsd__decimal(soap, &this->_ns1__GetLotteryWinningTop::prizeValue);
	/* transient soap skipped */
#endif
}

int _ns1__GetLotteryWinningTop::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLotteryWinningTop(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLotteryWinningTop(struct soap *soap, const char *tag, int id, const _ns1__GetLotteryWinningTop *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLotteryWinningTop), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:appCode", -1, &(a->_ns1__GetLotteryWinningTop::appCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:accessKey", -1, &(a->_ns1__GetLotteryWinningTop::accessKey), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:awardGuid", -1, &(a->_ns1__GetLotteryWinningTop::awardGuid), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:top", -1, &(a->_ns1__GetLotteryWinningTop::top), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:prizeIndex", -1, &(a->_ns1__GetLotteryWinningTop::prizeIndex), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:prizeID", -1, &(a->_ns1__GetLotteryWinningTop::prizeID), ""))
		return soap->error;
	if (a->_ns1__GetLotteryWinningTop::prizeValue)
	{	if (soap_out_xsd__decimal(soap, "ns1:prizeValue", -1, &a->_ns1__GetLotteryWinningTop::prizeValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:prizeValue"))
		return soap->error;
	if (soap_out_time(soap, "ns1:dtBegin", -1, &(a->_ns1__GetLotteryWinningTop::dtBegin), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:dtEnd", -1, &(a->_ns1__GetLotteryWinningTop::dtEnd), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLotteryWinningTop::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLotteryWinningTop(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningTop * SOAP_FMAC4 soap_in__ns1__GetLotteryWinningTop(struct soap *soap, const char *tag, _ns1__GetLotteryWinningTop *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLotteryWinningTop *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLotteryWinningTop, sizeof(_ns1__GetLotteryWinningTop), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLotteryWinningTop)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLotteryWinningTop *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_appCode1 = 1;
	size_t soap_flag_accessKey1 = 1;
	size_t soap_flag_awardGuid1 = 1;
	size_t soap_flag_top1 = 1;
	size_t soap_flag_prizeIndex1 = 1;
	size_t soap_flag_prizeID1 = 1;
	size_t soap_flag_prizeValue1 = 1;
	size_t soap_flag_dtBegin1 = 1;
	size_t soap_flag_dtEnd1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_appCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:appCode", &(a->_ns1__GetLotteryWinningTop::appCode), "xsd:string"))
				{	soap_flag_appCode1--;
					continue;
				}
			if (soap_flag_accessKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:accessKey", &(a->_ns1__GetLotteryWinningTop::accessKey), "xsd:string"))
				{	soap_flag_accessKey1--;
					continue;
				}
			if (soap_flag_awardGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:awardGuid", &(a->_ns1__GetLotteryWinningTop::awardGuid), "xsd:string"))
				{	soap_flag_awardGuid1--;
					continue;
				}
			if (soap_flag_top1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:top", &(a->_ns1__GetLotteryWinningTop::top), "xsd:int"))
				{	soap_flag_top1--;
					continue;
				}
			if (soap_flag_prizeIndex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:prizeIndex", &(a->_ns1__GetLotteryWinningTop::prizeIndex), "xsd:string"))
				{	soap_flag_prizeIndex1--;
					continue;
				}
			if (soap_flag_prizeID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:prizeID", &(a->_ns1__GetLotteryWinningTop::prizeID), "xsd:string"))
				{	soap_flag_prizeID1--;
					continue;
				}
			if (soap_flag_prizeValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:prizeValue", &(a->_ns1__GetLotteryWinningTop::prizeValue), "xsd:decimal"))
				{	soap_flag_prizeValue1--;
					continue;
				}
			if (soap_flag_dtBegin1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:dtBegin", &(a->_ns1__GetLotteryWinningTop::dtBegin), "xsd:dateTime"))
				{	soap_flag_dtBegin1--;
					continue;
				}
			if (soap_flag_dtEnd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:dtEnd", &(a->_ns1__GetLotteryWinningTop::dtEnd), "xsd:dateTime"))
				{	soap_flag_dtEnd1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLotteryWinningTop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLotteryWinningTop, 0, sizeof(_ns1__GetLotteryWinningTop), 0, soap_copy__ns1__GetLotteryWinningTop);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_top1 > 0 || soap_flag_prizeValue1 > 0 || soap_flag_dtBegin1 > 0 || soap_flag_dtEnd1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetLotteryWinningTop::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetLotteryWinningTop);
	if (this->soap_out(soap, tag?tag:"ns1:GetLotteryWinningTop", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLotteryWinningTop::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLotteryWinningTop(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningTop * SOAP_FMAC4 soap_get__ns1__GetLotteryWinningTop(struct soap *soap, _ns1__GetLotteryWinningTop *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLotteryWinningTop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLotteryWinningTop * SOAP_FMAC2 soap_instantiate__ns1__GetLotteryWinningTop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLotteryWinningTop(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLotteryWinningTop, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLotteryWinningTop);
		if (size)
			*size = sizeof(_ns1__GetLotteryWinningTop);
		((_ns1__GetLotteryWinningTop*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetLotteryWinningTop, n);
		if (size)
			*size = n * sizeof(_ns1__GetLotteryWinningTop);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetLotteryWinningTop*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetLotteryWinningTop*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLotteryWinningTop(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLotteryWinningTop %p -> %p\n", q, p));
	*(_ns1__GetLotteryWinningTop*)p = *(_ns1__GetLotteryWinningTop*)q;
}

void _ns1__GetLotteryPrizeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetLotteryPrizeResponse::GetLotteryPrizeResult = NULL;
	soap_default_string(soap, &this->_ns1__GetLotteryPrizeResponse::msg);
	/* transient soap skipped */
}

void _ns1__GetLotteryPrizeResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfAwardLotteryPrizeInfo(soap, &this->_ns1__GetLotteryPrizeResponse::GetLotteryPrizeResult);
	soap_serialize_string(soap, &this->_ns1__GetLotteryPrizeResponse::msg);
	/* transient soap skipped */
#endif
}

int _ns1__GetLotteryPrizeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLotteryPrizeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLotteryPrizeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLotteryPrizeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLotteryPrizeResponse), type))
		return soap->error;
	if (a->GetLotteryPrizeResult)
		soap_element_result(soap, "ns1:GetLotteryPrizeResult");
	if (soap_out_PointerTons1__ArrayOfAwardLotteryPrizeInfo(soap, "ns1:GetLotteryPrizeResult", -1, &(a->_ns1__GetLotteryPrizeResponse::GetLotteryPrizeResult), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:msg", -1, &(a->_ns1__GetLotteryPrizeResponse::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLotteryPrizeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLotteryPrizeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLotteryPrizeResponse * SOAP_FMAC4 soap_in__ns1__GetLotteryPrizeResponse(struct soap *soap, const char *tag, _ns1__GetLotteryPrizeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLotteryPrizeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLotteryPrizeResponse, sizeof(_ns1__GetLotteryPrizeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLotteryPrizeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLotteryPrizeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetLotteryPrizeResult1 = 1;
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLotteryPrizeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAwardLotteryPrizeInfo(soap, "ns1:GetLotteryPrizeResult", &(a->_ns1__GetLotteryPrizeResponse::GetLotteryPrizeResult), "ns1:ArrayOfAwardLotteryPrizeInfo"))
				{	soap_flag_GetLotteryPrizeResult1--;
					continue;
				}
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:msg", &(a->_ns1__GetLotteryPrizeResponse::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetLotteryPrizeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLotteryPrizeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLotteryPrizeResponse, 0, sizeof(_ns1__GetLotteryPrizeResponse), 0, soap_copy__ns1__GetLotteryPrizeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetLotteryPrizeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetLotteryPrizeResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetLotteryPrizeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLotteryPrizeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLotteryPrizeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLotteryPrizeResponse * SOAP_FMAC4 soap_get__ns1__GetLotteryPrizeResponse(struct soap *soap, _ns1__GetLotteryPrizeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLotteryPrizeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLotteryPrizeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLotteryPrizeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLotteryPrizeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLotteryPrizeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLotteryPrizeResponse);
		if (size)
			*size = sizeof(_ns1__GetLotteryPrizeResponse);
		((_ns1__GetLotteryPrizeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetLotteryPrizeResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetLotteryPrizeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetLotteryPrizeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetLotteryPrizeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLotteryPrizeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLotteryPrizeResponse %p -> %p\n", q, p));
	*(_ns1__GetLotteryPrizeResponse*)p = *(_ns1__GetLotteryPrizeResponse*)q;
}

void _ns1__GetLotteryPrize::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetLotteryPrize::appCode);
	soap_default_string(soap, &this->_ns1__GetLotteryPrize::accessKey);
	soap_default_string(soap, &this->_ns1__GetLotteryPrize::awardGuid);
	/* transient soap skipped */
}

void _ns1__GetLotteryPrize::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetLotteryPrize::appCode);
	soap_serialize_string(soap, &this->_ns1__GetLotteryPrize::accessKey);
	soap_serialize_string(soap, &this->_ns1__GetLotteryPrize::awardGuid);
	/* transient soap skipped */
#endif
}

int _ns1__GetLotteryPrize::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLotteryPrize(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLotteryPrize(struct soap *soap, const char *tag, int id, const _ns1__GetLotteryPrize *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLotteryPrize), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:appCode", -1, &(a->_ns1__GetLotteryPrize::appCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:accessKey", -1, &(a->_ns1__GetLotteryPrize::accessKey), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:awardGuid", -1, &(a->_ns1__GetLotteryPrize::awardGuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLotteryPrize::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLotteryPrize(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLotteryPrize * SOAP_FMAC4 soap_in__ns1__GetLotteryPrize(struct soap *soap, const char *tag, _ns1__GetLotteryPrize *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLotteryPrize *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLotteryPrize, sizeof(_ns1__GetLotteryPrize), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLotteryPrize)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLotteryPrize *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_appCode1 = 1;
	size_t soap_flag_accessKey1 = 1;
	size_t soap_flag_awardGuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_appCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:appCode", &(a->_ns1__GetLotteryPrize::appCode), "xsd:string"))
				{	soap_flag_appCode1--;
					continue;
				}
			if (soap_flag_accessKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:accessKey", &(a->_ns1__GetLotteryPrize::accessKey), "xsd:string"))
				{	soap_flag_accessKey1--;
					continue;
				}
			if (soap_flag_awardGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:awardGuid", &(a->_ns1__GetLotteryPrize::awardGuid), "xsd:string"))
				{	soap_flag_awardGuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLotteryPrize *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLotteryPrize, 0, sizeof(_ns1__GetLotteryPrize), 0, soap_copy__ns1__GetLotteryPrize);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetLotteryPrize::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetLotteryPrize);
	if (this->soap_out(soap, tag?tag:"ns1:GetLotteryPrize", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLotteryPrize::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLotteryPrize(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLotteryPrize * SOAP_FMAC4 soap_get__ns1__GetLotteryPrize(struct soap *soap, _ns1__GetLotteryPrize *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLotteryPrize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLotteryPrize * SOAP_FMAC2 soap_instantiate__ns1__GetLotteryPrize(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLotteryPrize(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLotteryPrize, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLotteryPrize);
		if (size)
			*size = sizeof(_ns1__GetLotteryPrize);
		((_ns1__GetLotteryPrize*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetLotteryPrize, n);
		if (size)
			*size = n * sizeof(_ns1__GetLotteryPrize);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetLotteryPrize*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetLotteryPrize*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLotteryPrize(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLotteryPrize %p -> %p\n", q, p));
	*(_ns1__GetLotteryPrize*)p = *(_ns1__GetLotteryPrize*)q;
}

void _ns1__LotteryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__LotteryResponse::LotteryResult);
	this->_ns1__LotteryResponse::prizeInfo = NULL;
	soap_default_string(soap, &this->_ns1__LotteryResponse::msg);
	/* transient soap skipped */
}

void _ns1__LotteryResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AwardLotteryPrizeInfo(soap, &this->_ns1__LotteryResponse::prizeInfo);
	soap_serialize_string(soap, &this->_ns1__LotteryResponse::msg);
	/* transient soap skipped */
#endif
}

int _ns1__LotteryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LotteryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LotteryResponse(struct soap *soap, const char *tag, int id, const _ns1__LotteryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LotteryResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:LotteryResult");
	if (soap_out_bool(soap, "ns1:LotteryResult", -1, &(a->_ns1__LotteryResponse::LotteryResult), ""))
		return soap->error;
	if (soap_out_PointerTons1__AwardLotteryPrizeInfo(soap, "ns1:prizeInfo", -1, &(a->_ns1__LotteryResponse::prizeInfo), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:msg", -1, &(a->_ns1__LotteryResponse::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__LotteryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LotteryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LotteryResponse * SOAP_FMAC4 soap_in__ns1__LotteryResponse(struct soap *soap, const char *tag, _ns1__LotteryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LotteryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LotteryResponse, sizeof(_ns1__LotteryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__LotteryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__LotteryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LotteryResult1 = 1;
	size_t soap_flag_prizeInfo1 = 1;
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LotteryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:LotteryResult", &(a->_ns1__LotteryResponse::LotteryResult), "xsd:boolean"))
				{	soap_flag_LotteryResult1--;
					continue;
				}
			if (soap_flag_prizeInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AwardLotteryPrizeInfo(soap, "ns1:prizeInfo", &(a->_ns1__LotteryResponse::prizeInfo), "ns1:AwardLotteryPrizeInfo"))
				{	soap_flag_prizeInfo1--;
					continue;
				}
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:msg", &(a->_ns1__LotteryResponse::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:LotteryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LotteryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LotteryResponse, 0, sizeof(_ns1__LotteryResponse), 0, soap_copy__ns1__LotteryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LotteryResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__LotteryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__LotteryResponse);
	if (this->soap_out(soap, tag?tag:"ns1:LotteryResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LotteryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LotteryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LotteryResponse * SOAP_FMAC4 soap_get__ns1__LotteryResponse(struct soap *soap, _ns1__LotteryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LotteryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__LotteryResponse * SOAP_FMAC2 soap_instantiate__ns1__LotteryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LotteryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__LotteryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__LotteryResponse);
		if (size)
			*size = sizeof(_ns1__LotteryResponse);
		((_ns1__LotteryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__LotteryResponse, n);
		if (size)
			*size = n * sizeof(_ns1__LotteryResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__LotteryResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__LotteryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__LotteryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__LotteryResponse %p -> %p\n", q, p));
	*(_ns1__LotteryResponse*)p = *(_ns1__LotteryResponse*)q;
}

void _ns1__Lottery::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__Lottery::appCode);
	soap_default_string(soap, &this->_ns1__Lottery::accessKey);
	soap_default_string(soap, &this->_ns1__Lottery::awardGuid);
	soap_default_int(soap, &this->_ns1__Lottery::userID);
	soap_default_string(soap, &this->_ns1__Lottery::userName);
	soap_default_string(soap, &this->_ns1__Lottery::userIP);
	soap_default_string(soap, &this->_ns1__Lottery::credential);
	soap_default_string(soap, &this->_ns1__Lottery::remark);
	/* transient soap skipped */
}

void _ns1__Lottery::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__Lottery::appCode);
	soap_serialize_string(soap, &this->_ns1__Lottery::accessKey);
	soap_serialize_string(soap, &this->_ns1__Lottery::awardGuid);
	soap_serialize_string(soap, &this->_ns1__Lottery::userName);
	soap_serialize_string(soap, &this->_ns1__Lottery::userIP);
	soap_serialize_string(soap, &this->_ns1__Lottery::credential);
	soap_serialize_string(soap, &this->_ns1__Lottery::remark);
	/* transient soap skipped */
#endif
}

int _ns1__Lottery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Lottery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Lottery(struct soap *soap, const char *tag, int id, const _ns1__Lottery *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Lottery), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:appCode", -1, &(a->_ns1__Lottery::appCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:accessKey", -1, &(a->_ns1__Lottery::accessKey), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:awardGuid", -1, &(a->_ns1__Lottery::awardGuid), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:userID", -1, &(a->_ns1__Lottery::userID), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->_ns1__Lottery::userName), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:userIP", -1, &(a->_ns1__Lottery::userIP), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:credential", -1, &(a->_ns1__Lottery::credential), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:remark", -1, &(a->_ns1__Lottery::remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__Lottery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Lottery(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Lottery * SOAP_FMAC4 soap_in__ns1__Lottery(struct soap *soap, const char *tag, _ns1__Lottery *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Lottery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Lottery, sizeof(_ns1__Lottery), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__Lottery)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__Lottery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_appCode1 = 1;
	size_t soap_flag_accessKey1 = 1;
	size_t soap_flag_awardGuid1 = 1;
	size_t soap_flag_userID1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_userIP1 = 1;
	size_t soap_flag_credential1 = 1;
	size_t soap_flag_remark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_appCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:appCode", &(a->_ns1__Lottery::appCode), "xsd:string"))
				{	soap_flag_appCode1--;
					continue;
				}
			if (soap_flag_accessKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:accessKey", &(a->_ns1__Lottery::accessKey), "xsd:string"))
				{	soap_flag_accessKey1--;
					continue;
				}
			if (soap_flag_awardGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:awardGuid", &(a->_ns1__Lottery::awardGuid), "xsd:string"))
				{	soap_flag_awardGuid1--;
					continue;
				}
			if (soap_flag_userID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:userID", &(a->_ns1__Lottery::userID), "xsd:int"))
				{	soap_flag_userID1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->_ns1__Lottery::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_userIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userIP", &(a->_ns1__Lottery::userIP), "xsd:string"))
				{	soap_flag_userIP1--;
					continue;
				}
			if (soap_flag_credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:credential", &(a->_ns1__Lottery::credential), "xsd:string"))
				{	soap_flag_credential1--;
					continue;
				}
			if (soap_flag_remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:remark", &(a->_ns1__Lottery::remark), "xsd:string"))
				{	soap_flag_remark1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Lottery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Lottery, 0, sizeof(_ns1__Lottery), 0, soap_copy__ns1__Lottery);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__Lottery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__Lottery);
	if (this->soap_out(soap, tag?tag:"ns1:Lottery", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Lottery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Lottery(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Lottery * SOAP_FMAC4 soap_get__ns1__Lottery(struct soap *soap, _ns1__Lottery *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Lottery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__Lottery * SOAP_FMAC2 soap_instantiate__ns1__Lottery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Lottery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__Lottery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__Lottery);
		if (size)
			*size = sizeof(_ns1__Lottery);
		((_ns1__Lottery*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__Lottery, n);
		if (size)
			*size = n * sizeof(_ns1__Lottery);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__Lottery*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__Lottery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__Lottery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__Lottery %p -> %p\n", q, p));
	*(_ns1__Lottery*)p = *(_ns1__Lottery*)q;
}

void _ns1__GetAwardInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAwardInfoResponse::GetAwardInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetAwardInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AwardInfo(soap, &this->_ns1__GetAwardInfoResponse::GetAwardInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetAwardInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAwardInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAwardInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAwardInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAwardInfoResponse), type))
		return soap->error;
	if (a->GetAwardInfoResult)
		soap_element_result(soap, "ns1:GetAwardInfoResult");
	if (soap_out_PointerTons1__AwardInfo(soap, "ns1:GetAwardInfoResult", -1, &(a->_ns1__GetAwardInfoResponse::GetAwardInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAwardInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAwardInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAwardInfoResponse * SOAP_FMAC4 soap_in__ns1__GetAwardInfoResponse(struct soap *soap, const char *tag, _ns1__GetAwardInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAwardInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAwardInfoResponse, sizeof(_ns1__GetAwardInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAwardInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAwardInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetAwardInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAwardInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AwardInfo(soap, "ns1:GetAwardInfoResult", &(a->_ns1__GetAwardInfoResponse::GetAwardInfoResult), "ns1:AwardInfo"))
				{	soap_flag_GetAwardInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetAwardInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAwardInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAwardInfoResponse, 0, sizeof(_ns1__GetAwardInfoResponse), 0, soap_copy__ns1__GetAwardInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAwardInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAwardInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetAwardInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAwardInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAwardInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAwardInfoResponse * SOAP_FMAC4 soap_get__ns1__GetAwardInfoResponse(struct soap *soap, _ns1__GetAwardInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAwardInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAwardInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAwardInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAwardInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAwardInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAwardInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetAwardInfoResponse);
		((_ns1__GetAwardInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAwardInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetAwardInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAwardInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAwardInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAwardInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAwardInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetAwardInfoResponse*)p = *(_ns1__GetAwardInfoResponse*)q;
}

void _ns1__GetAwardInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetAwardInfo::awardGuid);
	/* transient soap skipped */
}

void _ns1__GetAwardInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetAwardInfo::awardGuid);
	/* transient soap skipped */
#endif
}

int _ns1__GetAwardInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAwardInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAwardInfo(struct soap *soap, const char *tag, int id, const _ns1__GetAwardInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAwardInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:awardGuid", -1, &(a->_ns1__GetAwardInfo::awardGuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAwardInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAwardInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAwardInfo * SOAP_FMAC4 soap_in__ns1__GetAwardInfo(struct soap *soap, const char *tag, _ns1__GetAwardInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAwardInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAwardInfo, sizeof(_ns1__GetAwardInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAwardInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAwardInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_awardGuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_awardGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:awardGuid", &(a->_ns1__GetAwardInfo::awardGuid), "xsd:string"))
				{	soap_flag_awardGuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAwardInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAwardInfo, 0, sizeof(_ns1__GetAwardInfo), 0, soap_copy__ns1__GetAwardInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAwardInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAwardInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetAwardInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAwardInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAwardInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAwardInfo * SOAP_FMAC4 soap_get__ns1__GetAwardInfo(struct soap *soap, _ns1__GetAwardInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAwardInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAwardInfo * SOAP_FMAC2 soap_instantiate__ns1__GetAwardInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAwardInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAwardInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAwardInfo);
		if (size)
			*size = sizeof(_ns1__GetAwardInfo);
		((_ns1__GetAwardInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAwardInfo, n);
		if (size)
			*size = n * sizeof(_ns1__GetAwardInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAwardInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAwardInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAwardInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAwardInfo %p -> %p\n", q, p));
	*(_ns1__GetAwardInfo*)p = *(_ns1__GetAwardInfo*)q;
}

void _ns1__GetAwardItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAwardItemResponse::GetAwardItemResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetAwardItemResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfAwardItemInfo(soap, &this->_ns1__GetAwardItemResponse::GetAwardItemResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetAwardItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAwardItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAwardItemResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAwardItemResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAwardItemResponse), type))
		return soap->error;
	if (a->GetAwardItemResult)
		soap_element_result(soap, "ns1:GetAwardItemResult");
	if (soap_out_PointerTons1__ArrayOfAwardItemInfo(soap, "ns1:GetAwardItemResult", -1, &(a->_ns1__GetAwardItemResponse::GetAwardItemResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAwardItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAwardItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAwardItemResponse * SOAP_FMAC4 soap_in__ns1__GetAwardItemResponse(struct soap *soap, const char *tag, _ns1__GetAwardItemResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAwardItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAwardItemResponse, sizeof(_ns1__GetAwardItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAwardItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAwardItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetAwardItemResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAwardItemResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfAwardItemInfo(soap, "ns1:GetAwardItemResult", &(a->_ns1__GetAwardItemResponse::GetAwardItemResult), "ns1:ArrayOfAwardItemInfo"))
				{	soap_flag_GetAwardItemResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetAwardItemResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAwardItemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAwardItemResponse, 0, sizeof(_ns1__GetAwardItemResponse), 0, soap_copy__ns1__GetAwardItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAwardItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAwardItemResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetAwardItemResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAwardItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAwardItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAwardItemResponse * SOAP_FMAC4 soap_get__ns1__GetAwardItemResponse(struct soap *soap, _ns1__GetAwardItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAwardItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAwardItemResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAwardItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAwardItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAwardItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAwardItemResponse);
		if (size)
			*size = sizeof(_ns1__GetAwardItemResponse);
		((_ns1__GetAwardItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAwardItemResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetAwardItemResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAwardItemResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAwardItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAwardItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAwardItemResponse %p -> %p\n", q, p));
	*(_ns1__GetAwardItemResponse*)p = *(_ns1__GetAwardItemResponse*)q;
}

void _ns1__GetAwardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetAwardItem::awardGuid);
	/* transient soap skipped */
}

void _ns1__GetAwardItem::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetAwardItem::awardGuid);
	/* transient soap skipped */
#endif
}

int _ns1__GetAwardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAwardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAwardItem(struct soap *soap, const char *tag, int id, const _ns1__GetAwardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAwardItem), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:awardGuid", -1, &(a->_ns1__GetAwardItem::awardGuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAwardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAwardItem(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAwardItem * SOAP_FMAC4 soap_in__ns1__GetAwardItem(struct soap *soap, const char *tag, _ns1__GetAwardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAwardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAwardItem, sizeof(_ns1__GetAwardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAwardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAwardItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_awardGuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_awardGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:awardGuid", &(a->_ns1__GetAwardItem::awardGuid), "xsd:string"))
				{	soap_flag_awardGuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAwardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAwardItem, 0, sizeof(_ns1__GetAwardItem), 0, soap_copy__ns1__GetAwardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAwardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAwardItem);
	if (this->soap_out(soap, tag?tag:"ns1:GetAwardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAwardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAwardItem(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAwardItem * SOAP_FMAC4 soap_get__ns1__GetAwardItem(struct soap *soap, _ns1__GetAwardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAwardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAwardItem * SOAP_FMAC2 soap_instantiate__ns1__GetAwardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAwardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAwardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAwardItem);
		if (size)
			*size = sizeof(_ns1__GetAwardItem);
		((_ns1__GetAwardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAwardItem, n);
		if (size)
			*size = n * sizeof(_ns1__GetAwardItem);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAwardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAwardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAwardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAwardItem %p -> %p\n", q, p));
	*(_ns1__GetAwardItem*)p = *(_ns1__GetAwardItem*)q;
}

void _ns1__AwardItemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__AwardItemResponse::AwardItemResult);
	soap_default_string(soap, &this->_ns1__AwardItemResponse::msg);
	/* transient soap skipped */
}

void _ns1__AwardItemResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AwardItemResponse::msg);
	/* transient soap skipped */
#endif
}

int _ns1__AwardItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AwardItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AwardItemResponse(struct soap *soap, const char *tag, int id, const _ns1__AwardItemResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AwardItemResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:AwardItemResult");
	if (soap_out_bool(soap, "ns1:AwardItemResult", -1, &(a->_ns1__AwardItemResponse::AwardItemResult), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:msg", -1, &(a->_ns1__AwardItemResponse::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AwardItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AwardItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AwardItemResponse * SOAP_FMAC4 soap_in__ns1__AwardItemResponse(struct soap *soap, const char *tag, _ns1__AwardItemResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AwardItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AwardItemResponse, sizeof(_ns1__AwardItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AwardItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AwardItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AwardItemResult1 = 1;
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AwardItemResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:AwardItemResult", &(a->_ns1__AwardItemResponse::AwardItemResult), "xsd:boolean"))
				{	soap_flag_AwardItemResult1--;
					continue;
				}
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:msg", &(a->_ns1__AwardItemResponse::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:AwardItemResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AwardItemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AwardItemResponse, 0, sizeof(_ns1__AwardItemResponse), 0, soap_copy__ns1__AwardItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AwardItemResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__AwardItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AwardItemResponse);
	if (this->soap_out(soap, tag?tag:"ns1:AwardItemResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AwardItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AwardItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AwardItemResponse * SOAP_FMAC4 soap_get__ns1__AwardItemResponse(struct soap *soap, _ns1__AwardItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AwardItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AwardItemResponse * SOAP_FMAC2 soap_instantiate__ns1__AwardItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AwardItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AwardItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AwardItemResponse);
		if (size)
			*size = sizeof(_ns1__AwardItemResponse);
		((_ns1__AwardItemResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__AwardItemResponse, n);
		if (size)
			*size = n * sizeof(_ns1__AwardItemResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__AwardItemResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__AwardItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AwardItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AwardItemResponse %p -> %p\n", q, p));
	*(_ns1__AwardItemResponse*)p = *(_ns1__AwardItemResponse*)q;
}

void _ns1__AwardItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AwardItem::appCode);
	soap_default_string(soap, &this->_ns1__AwardItem::accessKey);
	soap_default_string(soap, &this->_ns1__AwardItem::awardGuid);
	soap_default_int(soap, &this->_ns1__AwardItem::userID);
	soap_default_string(soap, &this->_ns1__AwardItem::userName);
	soap_default_string(soap, &this->_ns1__AwardItem::userIP);
	soap_default_string(soap, &this->_ns1__AwardItem::designationItem);
	/* transient soap skipped */
}

void _ns1__AwardItem::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__AwardItem::appCode);
	soap_serialize_string(soap, &this->_ns1__AwardItem::accessKey);
	soap_serialize_string(soap, &this->_ns1__AwardItem::awardGuid);
	soap_serialize_string(soap, &this->_ns1__AwardItem::userName);
	soap_serialize_string(soap, &this->_ns1__AwardItem::userIP);
	soap_serialize_string(soap, &this->_ns1__AwardItem::designationItem);
	/* transient soap skipped */
#endif
}

int _ns1__AwardItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AwardItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AwardItem(struct soap *soap, const char *tag, int id, const _ns1__AwardItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AwardItem), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:appCode", -1, &(a->_ns1__AwardItem::appCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:accessKey", -1, &(a->_ns1__AwardItem::accessKey), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:awardGuid", -1, &(a->_ns1__AwardItem::awardGuid), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:userID", -1, &(a->_ns1__AwardItem::userID), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:userName", -1, &(a->_ns1__AwardItem::userName), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:userIP", -1, &(a->_ns1__AwardItem::userIP), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:designationItem", -1, &(a->_ns1__AwardItem::designationItem), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__AwardItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AwardItem(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AwardItem * SOAP_FMAC4 soap_in__ns1__AwardItem(struct soap *soap, const char *tag, _ns1__AwardItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AwardItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AwardItem, sizeof(_ns1__AwardItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__AwardItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__AwardItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_appCode1 = 1;
	size_t soap_flag_accessKey1 = 1;
	size_t soap_flag_awardGuid1 = 1;
	size_t soap_flag_userID1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_userIP1 = 1;
	size_t soap_flag_designationItem1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_appCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:appCode", &(a->_ns1__AwardItem::appCode), "xsd:string"))
				{	soap_flag_appCode1--;
					continue;
				}
			if (soap_flag_accessKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:accessKey", &(a->_ns1__AwardItem::accessKey), "xsd:string"))
				{	soap_flag_accessKey1--;
					continue;
				}
			if (soap_flag_awardGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:awardGuid", &(a->_ns1__AwardItem::awardGuid), "xsd:string"))
				{	soap_flag_awardGuid1--;
					continue;
				}
			if (soap_flag_userID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:userID", &(a->_ns1__AwardItem::userID), "xsd:int"))
				{	soap_flag_userID1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userName", &(a->_ns1__AwardItem::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_userIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userIP", &(a->_ns1__AwardItem::userIP), "xsd:string"))
				{	soap_flag_userIP1--;
					continue;
				}
			if (soap_flag_designationItem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:designationItem", &(a->_ns1__AwardItem::designationItem), "xsd:string"))
				{	soap_flag_designationItem1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__AwardItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AwardItem, 0, sizeof(_ns1__AwardItem), 0, soap_copy__ns1__AwardItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__AwardItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__AwardItem);
	if (this->soap_out(soap, tag?tag:"ns1:AwardItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AwardItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AwardItem(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AwardItem * SOAP_FMAC4 soap_get__ns1__AwardItem(struct soap *soap, _ns1__AwardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AwardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__AwardItem * SOAP_FMAC2 soap_instantiate__ns1__AwardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AwardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__AwardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__AwardItem);
		if (size)
			*size = sizeof(_ns1__AwardItem);
		((_ns1__AwardItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__AwardItem, n);
		if (size)
			*size = n * sizeof(_ns1__AwardItem);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__AwardItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__AwardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__AwardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__AwardItem %p -> %p\n", q, p));
	*(_ns1__AwardItem*)p = *(_ns1__AwardItem*)q;
}

void _ns1__GetClothingIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetClothingIDResponse::GetClothingIDResult);
	/* transient soap skipped */
}

void _ns1__GetClothingIDResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__GetClothingIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetClothingIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetClothingIDResponse(struct soap *soap, const char *tag, int id, const _ns1__GetClothingIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetClothingIDResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:GetClothingIDResult");
	if (soap_out_int(soap, "ns1:GetClothingIDResult", -1, &(a->_ns1__GetClothingIDResponse::GetClothingIDResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetClothingIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetClothingIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetClothingIDResponse * SOAP_FMAC4 soap_in__ns1__GetClothingIDResponse(struct soap *soap, const char *tag, _ns1__GetClothingIDResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetClothingIDResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetClothingIDResponse, sizeof(_ns1__GetClothingIDResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetClothingIDResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetClothingIDResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetClothingIDResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetClothingIDResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:GetClothingIDResult", &(a->_ns1__GetClothingIDResponse::GetClothingIDResult), "xsd:int"))
				{	soap_flag_GetClothingIDResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetClothingIDResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetClothingIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetClothingIDResponse, 0, sizeof(_ns1__GetClothingIDResponse), 0, soap_copy__ns1__GetClothingIDResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetClothingIDResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetClothingIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetClothingIDResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetClothingIDResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetClothingIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetClothingIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetClothingIDResponse * SOAP_FMAC4 soap_get__ns1__GetClothingIDResponse(struct soap *soap, _ns1__GetClothingIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetClothingIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetClothingIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GetClothingIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetClothingIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetClothingIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetClothingIDResponse);
		if (size)
			*size = sizeof(_ns1__GetClothingIDResponse);
		((_ns1__GetClothingIDResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetClothingIDResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetClothingIDResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetClothingIDResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetClothingIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetClothingIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetClothingIDResponse %p -> %p\n", q, p));
	*(_ns1__GetClothingIDResponse*)p = *(_ns1__GetClothingIDResponse*)q;
}

void _ns1__GetClothingID::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetClothingID::itemID);
	/* transient soap skipped */
}

void _ns1__GetClothingID::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__GetClothingID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetClothingID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetClothingID(struct soap *soap, const char *tag, int id, const _ns1__GetClothingID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetClothingID), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:itemID", -1, &(a->_ns1__GetClothingID::itemID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetClothingID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetClothingID(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetClothingID * SOAP_FMAC4 soap_in__ns1__GetClothingID(struct soap *soap, const char *tag, _ns1__GetClothingID *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetClothingID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetClothingID, sizeof(_ns1__GetClothingID), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetClothingID)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetClothingID *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_itemID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_itemID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:itemID", &(a->_ns1__GetClothingID::itemID), "xsd:int"))
				{	soap_flag_itemID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetClothingID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetClothingID, 0, sizeof(_ns1__GetClothingID), 0, soap_copy__ns1__GetClothingID);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_itemID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetClothingID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetClothingID);
	if (this->soap_out(soap, tag?tag:"ns1:GetClothingID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetClothingID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetClothingID(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetClothingID * SOAP_FMAC4 soap_get__ns1__GetClothingID(struct soap *soap, _ns1__GetClothingID *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetClothingID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetClothingID * SOAP_FMAC2 soap_instantiate__ns1__GetClothingID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetClothingID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetClothingID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetClothingID);
		if (size)
			*size = sizeof(_ns1__GetClothingID);
		((_ns1__GetClothingID*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetClothingID, n);
		if (size)
			*size = n * sizeof(_ns1__GetClothingID);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetClothingID*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetClothingID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetClothingID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetClothingID %p -> %p\n", q, p));
	*(_ns1__GetClothingID*)p = *(_ns1__GetClothingID*)q;
}

void _ns1__GetItemValueResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__decimal(soap, &this->_ns1__GetItemValueResponse::GetItemValueResult);
	/* transient soap skipped */
}

void _ns1__GetItemValueResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__decimal(soap, &this->_ns1__GetItemValueResponse::GetItemValueResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetItemValueResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetItemValueResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetItemValueResponse(struct soap *soap, const char *tag, int id, const _ns1__GetItemValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetItemValueResponse), type))
		return soap->error;
	if (a->GetItemValueResult)
		soap_element_result(soap, "ns1:GetItemValueResult");
	if (a->_ns1__GetItemValueResponse::GetItemValueResult)
	{	if (soap_out_xsd__decimal(soap, "ns1:GetItemValueResult", -1, &a->_ns1__GetItemValueResponse::GetItemValueResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetItemValueResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetItemValueResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetItemValueResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetItemValueResponse * SOAP_FMAC4 soap_in__ns1__GetItemValueResponse(struct soap *soap, const char *tag, _ns1__GetItemValueResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetItemValueResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetItemValueResponse, sizeof(_ns1__GetItemValueResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetItemValueResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetItemValueResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetItemValueResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetItemValueResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:GetItemValueResult", &(a->_ns1__GetItemValueResponse::GetItemValueResult), "xsd:decimal"))
				{	soap_flag_GetItemValueResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetItemValueResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetItemValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetItemValueResponse, 0, sizeof(_ns1__GetItemValueResponse), 0, soap_copy__ns1__GetItemValueResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetItemValueResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetItemValueResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetItemValueResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetItemValueResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetItemValueResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetItemValueResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetItemValueResponse * SOAP_FMAC4 soap_get__ns1__GetItemValueResponse(struct soap *soap, _ns1__GetItemValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetItemValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetItemValueResponse * SOAP_FMAC2 soap_instantiate__ns1__GetItemValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetItemValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetItemValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetItemValueResponse);
		if (size)
			*size = sizeof(_ns1__GetItemValueResponse);
		((_ns1__GetItemValueResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetItemValueResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetItemValueResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetItemValueResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetItemValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetItemValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetItemValueResponse %p -> %p\n", q, p));
	*(_ns1__GetItemValueResponse*)p = *(_ns1__GetItemValueResponse*)q;
}

void _ns1__GetItemValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetItemValue::itemID);
	soap_default_int(soap, &this->_ns1__GetItemValue::unitID);
	/* transient soap skipped */
}

void _ns1__GetItemValue::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__GetItemValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetItemValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetItemValue(struct soap *soap, const char *tag, int id, const _ns1__GetItemValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetItemValue), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:itemID", -1, &(a->_ns1__GetItemValue::itemID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:unitID", -1, &(a->_ns1__GetItemValue::unitID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetItemValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetItemValue(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetItemValue * SOAP_FMAC4 soap_in__ns1__GetItemValue(struct soap *soap, const char *tag, _ns1__GetItemValue *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetItemValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetItemValue, sizeof(_ns1__GetItemValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetItemValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetItemValue *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_itemID1 = 1;
	size_t soap_flag_unitID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_itemID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:itemID", &(a->_ns1__GetItemValue::itemID), "xsd:int"))
				{	soap_flag_itemID1--;
					continue;
				}
			if (soap_flag_unitID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:unitID", &(a->_ns1__GetItemValue::unitID), "xsd:int"))
				{	soap_flag_unitID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetItemValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetItemValue, 0, sizeof(_ns1__GetItemValue), 0, soap_copy__ns1__GetItemValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_itemID1 > 0 || soap_flag_unitID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetItemValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetItemValue);
	if (this->soap_out(soap, tag?tag:"ns1:GetItemValue", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetItemValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetItemValue(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetItemValue * SOAP_FMAC4 soap_get__ns1__GetItemValue(struct soap *soap, _ns1__GetItemValue *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetItemValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetItemValue * SOAP_FMAC2 soap_instantiate__ns1__GetItemValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetItemValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetItemValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetItemValue);
		if (size)
			*size = sizeof(_ns1__GetItemValue);
		((_ns1__GetItemValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetItemValue, n);
		if (size)
			*size = n * sizeof(_ns1__GetItemValue);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetItemValue*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetItemValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetItemValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetItemValue %p -> %p\n", q, p));
	*(_ns1__GetItemValue*)p = *(_ns1__GetItemValue*)q;
}

void _ns1__GetItemByItemIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetItemByItemIDResponse::GetItemByItemIDResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetItemByItemIDResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ItemInfo(soap, &this->_ns1__GetItemByItemIDResponse::GetItemByItemIDResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetItemByItemIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetItemByItemIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetItemByItemIDResponse(struct soap *soap, const char *tag, int id, const _ns1__GetItemByItemIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetItemByItemIDResponse), type))
		return soap->error;
	if (a->GetItemByItemIDResult)
		soap_element_result(soap, "ns1:GetItemByItemIDResult");
	if (soap_out_PointerTons1__ItemInfo(soap, "ns1:GetItemByItemIDResult", -1, &(a->_ns1__GetItemByItemIDResponse::GetItemByItemIDResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetItemByItemIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetItemByItemIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetItemByItemIDResponse * SOAP_FMAC4 soap_in__ns1__GetItemByItemIDResponse(struct soap *soap, const char *tag, _ns1__GetItemByItemIDResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetItemByItemIDResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetItemByItemIDResponse, sizeof(_ns1__GetItemByItemIDResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetItemByItemIDResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetItemByItemIDResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetItemByItemIDResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetItemByItemIDResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemInfo(soap, "ns1:GetItemByItemIDResult", &(a->_ns1__GetItemByItemIDResponse::GetItemByItemIDResult), "ns1:ItemInfo"))
				{	soap_flag_GetItemByItemIDResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetItemByItemIDResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetItemByItemIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetItemByItemIDResponse, 0, sizeof(_ns1__GetItemByItemIDResponse), 0, soap_copy__ns1__GetItemByItemIDResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetItemByItemIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetItemByItemIDResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetItemByItemIDResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetItemByItemIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetItemByItemIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetItemByItemIDResponse * SOAP_FMAC4 soap_get__ns1__GetItemByItemIDResponse(struct soap *soap, _ns1__GetItemByItemIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetItemByItemIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetItemByItemIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GetItemByItemIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetItemByItemIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetItemByItemIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetItemByItemIDResponse);
		if (size)
			*size = sizeof(_ns1__GetItemByItemIDResponse);
		((_ns1__GetItemByItemIDResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetItemByItemIDResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetItemByItemIDResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetItemByItemIDResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetItemByItemIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetItemByItemIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetItemByItemIDResponse %p -> %p\n", q, p));
	*(_ns1__GetItemByItemIDResponse*)p = *(_ns1__GetItemByItemIDResponse*)q;
}

void _ns1__GetItemByItemID::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetItemByItemID::itemID);
	/* transient soap skipped */
}

void _ns1__GetItemByItemID::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__GetItemByItemID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetItemByItemID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetItemByItemID(struct soap *soap, const char *tag, int id, const _ns1__GetItemByItemID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetItemByItemID), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:itemID", -1, &(a->_ns1__GetItemByItemID::itemID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetItemByItemID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetItemByItemID(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetItemByItemID * SOAP_FMAC4 soap_in__ns1__GetItemByItemID(struct soap *soap, const char *tag, _ns1__GetItemByItemID *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetItemByItemID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetItemByItemID, sizeof(_ns1__GetItemByItemID), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetItemByItemID)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetItemByItemID *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_itemID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_itemID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:itemID", &(a->_ns1__GetItemByItemID::itemID), "xsd:int"))
				{	soap_flag_itemID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetItemByItemID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetItemByItemID, 0, sizeof(_ns1__GetItemByItemID), 0, soap_copy__ns1__GetItemByItemID);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_itemID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetItemByItemID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetItemByItemID);
	if (this->soap_out(soap, tag?tag:"ns1:GetItemByItemID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetItemByItemID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetItemByItemID(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetItemByItemID * SOAP_FMAC4 soap_get__ns1__GetItemByItemID(struct soap *soap, _ns1__GetItemByItemID *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetItemByItemID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetItemByItemID * SOAP_FMAC2 soap_instantiate__ns1__GetItemByItemID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetItemByItemID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetItemByItemID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetItemByItemID);
		if (size)
			*size = sizeof(_ns1__GetItemByItemID);
		((_ns1__GetItemByItemID*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetItemByItemID, n);
		if (size)
			*size = n * sizeof(_ns1__GetItemByItemID);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetItemByItemID*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetItemByItemID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetItemByItemID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetItemByItemID %p -> %p\n", q, p));
	*(_ns1__GetItemByItemID*)p = *(_ns1__GetItemByItemID*)q;
}

void _ns1__GetItemByCodeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetItemByCodeResponse::GetItemByCodeResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetItemByCodeResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ItemInfo(soap, &this->_ns1__GetItemByCodeResponse::GetItemByCodeResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetItemByCodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetItemByCodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetItemByCodeResponse(struct soap *soap, const char *tag, int id, const _ns1__GetItemByCodeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetItemByCodeResponse), type))
		return soap->error;
	if (a->GetItemByCodeResult)
		soap_element_result(soap, "ns1:GetItemByCodeResult");
	if (soap_out_PointerTons1__ItemInfo(soap, "ns1:GetItemByCodeResult", -1, &(a->_ns1__GetItemByCodeResponse::GetItemByCodeResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetItemByCodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetItemByCodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetItemByCodeResponse * SOAP_FMAC4 soap_in__ns1__GetItemByCodeResponse(struct soap *soap, const char *tag, _ns1__GetItemByCodeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetItemByCodeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetItemByCodeResponse, sizeof(_ns1__GetItemByCodeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetItemByCodeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetItemByCodeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetItemByCodeResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetItemByCodeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemInfo(soap, "ns1:GetItemByCodeResult", &(a->_ns1__GetItemByCodeResponse::GetItemByCodeResult), "ns1:ItemInfo"))
				{	soap_flag_GetItemByCodeResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetItemByCodeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetItemByCodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetItemByCodeResponse, 0, sizeof(_ns1__GetItemByCodeResponse), 0, soap_copy__ns1__GetItemByCodeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetItemByCodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetItemByCodeResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetItemByCodeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetItemByCodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetItemByCodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetItemByCodeResponse * SOAP_FMAC4 soap_get__ns1__GetItemByCodeResponse(struct soap *soap, _ns1__GetItemByCodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetItemByCodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetItemByCodeResponse * SOAP_FMAC2 soap_instantiate__ns1__GetItemByCodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetItemByCodeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetItemByCodeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetItemByCodeResponse);
		if (size)
			*size = sizeof(_ns1__GetItemByCodeResponse);
		((_ns1__GetItemByCodeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetItemByCodeResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetItemByCodeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetItemByCodeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetItemByCodeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetItemByCodeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetItemByCodeResponse %p -> %p\n", q, p));
	*(_ns1__GetItemByCodeResponse*)p = *(_ns1__GetItemByCodeResponse*)q;
}

void _ns1__GetItemByCode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetItemByCode::itemCode);
	/* transient soap skipped */
}

void _ns1__GetItemByCode::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetItemByCode::itemCode);
	/* transient soap skipped */
#endif
}

int _ns1__GetItemByCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetItemByCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetItemByCode(struct soap *soap, const char *tag, int id, const _ns1__GetItemByCode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetItemByCode), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:itemCode", -1, &(a->_ns1__GetItemByCode::itemCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetItemByCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetItemByCode(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetItemByCode * SOAP_FMAC4 soap_in__ns1__GetItemByCode(struct soap *soap, const char *tag, _ns1__GetItemByCode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetItemByCode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetItemByCode, sizeof(_ns1__GetItemByCode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetItemByCode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetItemByCode *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_itemCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_itemCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:itemCode", &(a->_ns1__GetItemByCode::itemCode), "xsd:string"))
				{	soap_flag_itemCode1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetItemByCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetItemByCode, 0, sizeof(_ns1__GetItemByCode), 0, soap_copy__ns1__GetItemByCode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetItemByCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetItemByCode);
	if (this->soap_out(soap, tag?tag:"ns1:GetItemByCode", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetItemByCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetItemByCode(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetItemByCode * SOAP_FMAC4 soap_get__ns1__GetItemByCode(struct soap *soap, _ns1__GetItemByCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetItemByCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetItemByCode * SOAP_FMAC2 soap_instantiate__ns1__GetItemByCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetItemByCode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetItemByCode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetItemByCode);
		if (size)
			*size = sizeof(_ns1__GetItemByCode);
		((_ns1__GetItemByCode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetItemByCode, n);
		if (size)
			*size = n * sizeof(_ns1__GetItemByCode);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetItemByCode*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetItemByCode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetItemByCode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetItemByCode %p -> %p\n", q, p));
	*(_ns1__GetItemByCode*)p = *(_ns1__GetItemByCode*)q;
}

void ns1__ArrayOfAwardLotteryPrizeInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfAwardLotteryPrizeInfo::__sizeAwardLotteryPrizeInfo = 0;
	this->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfAwardLotteryPrizeInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfAwardLotteryPrizeInfo::__sizeAwardLotteryPrizeInfo; i++)
		{
			soap_serialize_PointerTons1__AwardLotteryPrizeInfo(soap, this->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo + i);
		}
	}
	/* transient soap skipped */
#endif
}

int ns1__ArrayOfAwardLotteryPrizeInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfAwardLotteryPrizeInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfAwardLotteryPrizeInfo(struct soap *soap, const char *tag, int id, const ns1__ArrayOfAwardLotteryPrizeInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo), type))
		return soap->error;
	if (a->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfAwardLotteryPrizeInfo::__sizeAwardLotteryPrizeInfo; i++)
			if (soap_out_PointerTons1__AwardLotteryPrizeInfo(soap, "ns1:AwardLotteryPrizeInfo", -1, a->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfAwardLotteryPrizeInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfAwardLotteryPrizeInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfAwardLotteryPrizeInfo * SOAP_FMAC4 soap_in_ns1__ArrayOfAwardLotteryPrizeInfo(struct soap *soap, const char *tag, ns1__ArrayOfAwardLotteryPrizeInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfAwardLotteryPrizeInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo, sizeof(ns1__ArrayOfAwardLotteryPrizeInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfAwardLotteryPrizeInfo *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_AwardLotteryPrizeInfo1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:AwardLotteryPrizeInfo", 1, NULL))
			{	if (a->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo == NULL)
				{	if (soap_blist_AwardLotteryPrizeInfo1 == NULL)
						soap_blist_AwardLotteryPrizeInfo1 = soap_new_block(soap);
					a->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo = (ns1__AwardLotteryPrizeInfo **)soap_push_block(soap, soap_blist_AwardLotteryPrizeInfo1, sizeof(ns1__AwardLotteryPrizeInfo *));
					if (a->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo == NULL)
						return NULL;
					*a->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__AwardLotteryPrizeInfo(soap, "ns1:AwardLotteryPrizeInfo", a->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo, "ns1:AwardLotteryPrizeInfo"))
				{	a->ns1__ArrayOfAwardLotteryPrizeInfo::__sizeAwardLotteryPrizeInfo++;
					a->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo)
			soap_pop_block(soap, soap_blist_AwardLotteryPrizeInfo1);
		if (a->ns1__ArrayOfAwardLotteryPrizeInfo::__sizeAwardLotteryPrizeInfo)
			a->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo = (ns1__AwardLotteryPrizeInfo **)soap_save_block(soap, soap_blist_AwardLotteryPrizeInfo1, NULL, 1);
		else
		{	a->ns1__ArrayOfAwardLotteryPrizeInfo::AwardLotteryPrizeInfo = NULL;
			if (soap_blist_AwardLotteryPrizeInfo1)
				soap_end_block(soap, soap_blist_AwardLotteryPrizeInfo1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfAwardLotteryPrizeInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo, 0, sizeof(ns1__ArrayOfAwardLotteryPrizeInfo), 0, soap_copy_ns1__ArrayOfAwardLotteryPrizeInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfAwardLotteryPrizeInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfAwardLotteryPrizeInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfAwardLotteryPrizeInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfAwardLotteryPrizeInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfAwardLotteryPrizeInfo * SOAP_FMAC4 soap_get_ns1__ArrayOfAwardLotteryPrizeInfo(struct soap *soap, ns1__ArrayOfAwardLotteryPrizeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfAwardLotteryPrizeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfAwardLotteryPrizeInfo * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfAwardLotteryPrizeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfAwardLotteryPrizeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfAwardLotteryPrizeInfo);
		if (size)
			*size = sizeof(ns1__ArrayOfAwardLotteryPrizeInfo);
		((ns1__ArrayOfAwardLotteryPrizeInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__ArrayOfAwardLotteryPrizeInfo, n);
		if (size)
			*size = n * sizeof(ns1__ArrayOfAwardLotteryPrizeInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfAwardLotteryPrizeInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__ArrayOfAwardLotteryPrizeInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfAwardLotteryPrizeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfAwardLotteryPrizeInfo %p -> %p\n", q, p));
	*(ns1__ArrayOfAwardLotteryPrizeInfo*)p = *(ns1__ArrayOfAwardLotteryPrizeInfo*)q;
}

void ns1__AwardLotteryPrizeInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__AwardLotteryPrizeInfo::PrizeID);
	soap_default_int(soap, &this->ns1__AwardLotteryPrizeInfo::AwardID);
	soap_default_string(soap, &this->ns1__AwardLotteryPrizeInfo::PrizeName);
	soap_default_string(soap, &this->ns1__AwardLotteryPrizeInfo::PrizeItemCode);
	soap_default_int(soap, &this->ns1__AwardLotteryPrizeInfo::PrizeIndex);
	soap_default_xsd__decimal(soap, &this->ns1__AwardLotteryPrizeInfo::WinningRate);
	soap_default_xsd__decimal(soap, &this->ns1__AwardLotteryPrizeInfo::PrizeValue);
	/* transient soap skipped */
}

void ns1__AwardLotteryPrizeInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__AwardLotteryPrizeInfo::PrizeName);
	soap_serialize_string(soap, &this->ns1__AwardLotteryPrizeInfo::PrizeItemCode);
	soap_serialize_xsd__decimal(soap, &this->ns1__AwardLotteryPrizeInfo::WinningRate);
	soap_serialize_xsd__decimal(soap, &this->ns1__AwardLotteryPrizeInfo::PrizeValue);
	/* transient soap skipped */
#endif
}

int ns1__AwardLotteryPrizeInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AwardLotteryPrizeInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AwardLotteryPrizeInfo(struct soap *soap, const char *tag, int id, const ns1__AwardLotteryPrizeInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AwardLotteryPrizeInfo), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:PrizeID", -1, &(a->ns1__AwardLotteryPrizeInfo::PrizeID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:AwardID", -1, &(a->ns1__AwardLotteryPrizeInfo::AwardID), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:PrizeName", -1, &(a->ns1__AwardLotteryPrizeInfo::PrizeName), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:PrizeItemCode", -1, &(a->ns1__AwardLotteryPrizeInfo::PrizeItemCode), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PrizeIndex", -1, &(a->ns1__AwardLotteryPrizeInfo::PrizeIndex), ""))
		return soap->error;
	if (a->ns1__AwardLotteryPrizeInfo::WinningRate)
	{	if (soap_out_xsd__decimal(soap, "ns1:WinningRate", -1, &a->ns1__AwardLotteryPrizeInfo::WinningRate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:WinningRate"))
		return soap->error;
	if (a->ns1__AwardLotteryPrizeInfo::PrizeValue)
	{	if (soap_out_xsd__decimal(soap, "ns1:PrizeValue", -1, &a->ns1__AwardLotteryPrizeInfo::PrizeValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:PrizeValue"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AwardLotteryPrizeInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AwardLotteryPrizeInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AwardLotteryPrizeInfo * SOAP_FMAC4 soap_in_ns1__AwardLotteryPrizeInfo(struct soap *soap, const char *tag, ns1__AwardLotteryPrizeInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AwardLotteryPrizeInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AwardLotteryPrizeInfo, sizeof(ns1__AwardLotteryPrizeInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AwardLotteryPrizeInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AwardLotteryPrizeInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PrizeID1 = 1;
	size_t soap_flag_AwardID1 = 1;
	size_t soap_flag_PrizeName1 = 1;
	size_t soap_flag_PrizeItemCode1 = 1;
	size_t soap_flag_PrizeIndex1 = 1;
	size_t soap_flag_WinningRate1 = 1;
	size_t soap_flag_PrizeValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PrizeID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PrizeID", &(a->ns1__AwardLotteryPrizeInfo::PrizeID), "xsd:int"))
				{	soap_flag_PrizeID1--;
					continue;
				}
			if (soap_flag_AwardID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:AwardID", &(a->ns1__AwardLotteryPrizeInfo::AwardID), "xsd:int"))
				{	soap_flag_AwardID1--;
					continue;
				}
			if (soap_flag_PrizeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PrizeName", &(a->ns1__AwardLotteryPrizeInfo::PrizeName), "xsd:string"))
				{	soap_flag_PrizeName1--;
					continue;
				}
			if (soap_flag_PrizeItemCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PrizeItemCode", &(a->ns1__AwardLotteryPrizeInfo::PrizeItemCode), "xsd:string"))
				{	soap_flag_PrizeItemCode1--;
					continue;
				}
			if (soap_flag_PrizeIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PrizeIndex", &(a->ns1__AwardLotteryPrizeInfo::PrizeIndex), "xsd:int"))
				{	soap_flag_PrizeIndex1--;
					continue;
				}
			if (soap_flag_WinningRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:WinningRate", &(a->ns1__AwardLotteryPrizeInfo::WinningRate), "xsd:decimal"))
				{	soap_flag_WinningRate1--;
					continue;
				}
			if (soap_flag_PrizeValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:PrizeValue", &(a->ns1__AwardLotteryPrizeInfo::PrizeValue), "xsd:decimal"))
				{	soap_flag_PrizeValue1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AwardLotteryPrizeInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AwardLotteryPrizeInfo, 0, sizeof(ns1__AwardLotteryPrizeInfo), 0, soap_copy_ns1__AwardLotteryPrizeInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PrizeID1 > 0 || soap_flag_AwardID1 > 0 || soap_flag_PrizeIndex1 > 0 || soap_flag_WinningRate1 > 0 || soap_flag_PrizeValue1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__AwardLotteryPrizeInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AwardLotteryPrizeInfo);
	if (this->soap_out(soap, tag?tag:"ns1:AwardLotteryPrizeInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AwardLotteryPrizeInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AwardLotteryPrizeInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AwardLotteryPrizeInfo * SOAP_FMAC4 soap_get_ns1__AwardLotteryPrizeInfo(struct soap *soap, ns1__AwardLotteryPrizeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AwardLotteryPrizeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__AwardLotteryPrizeInfo * SOAP_FMAC2 soap_instantiate_ns1__AwardLotteryPrizeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AwardLotteryPrizeInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AwardLotteryPrizeInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__AwardLotteryPrizeInfo);
		if (size)
			*size = sizeof(ns1__AwardLotteryPrizeInfo);
		((ns1__AwardLotteryPrizeInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__AwardLotteryPrizeInfo, n);
		if (size)
			*size = n * sizeof(ns1__AwardLotteryPrizeInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__AwardLotteryPrizeInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__AwardLotteryPrizeInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AwardLotteryPrizeInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AwardLotteryPrizeInfo %p -> %p\n", q, p));
	*(ns1__AwardLotteryPrizeInfo*)p = *(ns1__AwardLotteryPrizeInfo*)q;
}

void ns1__AwardInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__AwardInfo::AwardID);
	soap_default_string(soap, &this->ns1__AwardInfo::AwardGuid);
	soap_default_string(soap, &this->ns1__AwardInfo::Title);
	soap_default_int(soap, &this->ns1__AwardInfo::AwardType);
	soap_default_int(soap, &this->ns1__AwardInfo::TotalNumber);
	soap_default_int(soap, &this->ns1__AwardInfo::AwardedNumber);
	soap_default_time(soap, &this->ns1__AwardInfo::BeginTime);
	soap_default_time(soap, &this->ns1__AwardInfo::EndTime);
	soap_default_string(soap, &this->ns1__AwardInfo::AppsCode);
	soap_default_string(soap, &this->ns1__AwardInfo::Remark);
	soap_default_xsd__decimal(soap, &this->ns1__AwardInfo::TotalItemValue);
	soap_default_int(soap, &this->ns1__AwardInfo::StatusID);
	soap_default_int(soap, &this->ns1__AwardInfo::AdminID);
	soap_default_time(soap, &this->ns1__AwardInfo::Created);
	soap_default_bool(soap, &this->ns1__AwardInfo::IsAwardAgain);
	soap_default_bool(soap, &this->ns1__AwardInfo::IsLottery);
	/* transient soap skipped */
}

void ns1__AwardInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__AwardInfo::AwardGuid);
	soap_serialize_string(soap, &this->ns1__AwardInfo::Title);
	soap_serialize_string(soap, &this->ns1__AwardInfo::AppsCode);
	soap_serialize_string(soap, &this->ns1__AwardInfo::Remark);
	soap_serialize_xsd__decimal(soap, &this->ns1__AwardInfo::TotalItemValue);
	/* transient soap skipped */
#endif
}

int ns1__AwardInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AwardInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AwardInfo(struct soap *soap, const char *tag, int id, const ns1__AwardInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AwardInfo), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:AwardID", -1, &(a->ns1__AwardInfo::AwardID), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AwardGuid", -1, &(a->ns1__AwardInfo::AwardGuid), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Title", -1, &(a->ns1__AwardInfo::Title), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:AwardType", -1, &(a->ns1__AwardInfo::AwardType), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:TotalNumber", -1, &(a->ns1__AwardInfo::TotalNumber), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:AwardedNumber", -1, &(a->ns1__AwardInfo::AwardedNumber), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:BeginTime", -1, &(a->ns1__AwardInfo::BeginTime), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:EndTime", -1, &(a->ns1__AwardInfo::EndTime), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AppsCode", -1, &(a->ns1__AwardInfo::AppsCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Remark", -1, &(a->ns1__AwardInfo::Remark), ""))
		return soap->error;
	if (a->ns1__AwardInfo::TotalItemValue)
	{	if (soap_out_xsd__decimal(soap, "ns1:TotalItemValue", -1, &a->ns1__AwardInfo::TotalItemValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:TotalItemValue"))
		return soap->error;
	if (soap_out_int(soap, "ns1:StatusID", -1, &(a->ns1__AwardInfo::StatusID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:AdminID", -1, &(a->ns1__AwardInfo::AdminID), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:Created", -1, &(a->ns1__AwardInfo::Created), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsAwardAgain", -1, &(a->ns1__AwardInfo::IsAwardAgain), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsLottery", -1, &(a->ns1__AwardInfo::IsLottery), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AwardInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AwardInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AwardInfo * SOAP_FMAC4 soap_in_ns1__AwardInfo(struct soap *soap, const char *tag, ns1__AwardInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AwardInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AwardInfo, sizeof(ns1__AwardInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AwardInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AwardInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AwardID1 = 1;
	size_t soap_flag_AwardGuid1 = 1;
	size_t soap_flag_Title1 = 1;
	size_t soap_flag_AwardType1 = 1;
	size_t soap_flag_TotalNumber1 = 1;
	size_t soap_flag_AwardedNumber1 = 1;
	size_t soap_flag_BeginTime1 = 1;
	size_t soap_flag_EndTime1 = 1;
	size_t soap_flag_AppsCode1 = 1;
	size_t soap_flag_Remark1 = 1;
	size_t soap_flag_TotalItemValue1 = 1;
	size_t soap_flag_StatusID1 = 1;
	size_t soap_flag_AdminID1 = 1;
	size_t soap_flag_Created1 = 1;
	size_t soap_flag_IsAwardAgain1 = 1;
	size_t soap_flag_IsLottery1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AwardID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:AwardID", &(a->ns1__AwardInfo::AwardID), "xsd:int"))
				{	soap_flag_AwardID1--;
					continue;
				}
			if (soap_flag_AwardGuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AwardGuid", &(a->ns1__AwardInfo::AwardGuid), "xsd:string"))
				{	soap_flag_AwardGuid1--;
					continue;
				}
			if (soap_flag_Title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Title", &(a->ns1__AwardInfo::Title), "xsd:string"))
				{	soap_flag_Title1--;
					continue;
				}
			if (soap_flag_AwardType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:AwardType", &(a->ns1__AwardInfo::AwardType), "xsd:int"))
				{	soap_flag_AwardType1--;
					continue;
				}
			if (soap_flag_TotalNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:TotalNumber", &(a->ns1__AwardInfo::TotalNumber), "xsd:int"))
				{	soap_flag_TotalNumber1--;
					continue;
				}
			if (soap_flag_AwardedNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:AwardedNumber", &(a->ns1__AwardInfo::AwardedNumber), "xsd:int"))
				{	soap_flag_AwardedNumber1--;
					continue;
				}
			if (soap_flag_BeginTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:BeginTime", &(a->ns1__AwardInfo::BeginTime), "xsd:dateTime"))
				{	soap_flag_BeginTime1--;
					continue;
				}
			if (soap_flag_EndTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:EndTime", &(a->ns1__AwardInfo::EndTime), "xsd:dateTime"))
				{	soap_flag_EndTime1--;
					continue;
				}
			if (soap_flag_AppsCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AppsCode", &(a->ns1__AwardInfo::AppsCode), "xsd:string"))
				{	soap_flag_AppsCode1--;
					continue;
				}
			if (soap_flag_Remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Remark", &(a->ns1__AwardInfo::Remark), "xsd:string"))
				{	soap_flag_Remark1--;
					continue;
				}
			if (soap_flag_TotalItemValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:TotalItemValue", &(a->ns1__AwardInfo::TotalItemValue), "xsd:decimal"))
				{	soap_flag_TotalItemValue1--;
					continue;
				}
			if (soap_flag_StatusID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:StatusID", &(a->ns1__AwardInfo::StatusID), "xsd:int"))
				{	soap_flag_StatusID1--;
					continue;
				}
			if (soap_flag_AdminID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:AdminID", &(a->ns1__AwardInfo::AdminID), "xsd:int"))
				{	soap_flag_AdminID1--;
					continue;
				}
			if (soap_flag_Created1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:Created", &(a->ns1__AwardInfo::Created), "xsd:dateTime"))
				{	soap_flag_Created1--;
					continue;
				}
			if (soap_flag_IsAwardAgain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IsAwardAgain", &(a->ns1__AwardInfo::IsAwardAgain), "xsd:boolean"))
				{	soap_flag_IsAwardAgain1--;
					continue;
				}
			if (soap_flag_IsLottery1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IsLottery", &(a->ns1__AwardInfo::IsLottery), "xsd:boolean"))
				{	soap_flag_IsLottery1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AwardInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AwardInfo, 0, sizeof(ns1__AwardInfo), 0, soap_copy_ns1__AwardInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AwardID1 > 0 || soap_flag_AwardType1 > 0 || soap_flag_TotalNumber1 > 0 || soap_flag_AwardedNumber1 > 0 || soap_flag_BeginTime1 > 0 || soap_flag_EndTime1 > 0 || soap_flag_TotalItemValue1 > 0 || soap_flag_StatusID1 > 0 || soap_flag_AdminID1 > 0 || soap_flag_Created1 > 0 || soap_flag_IsAwardAgain1 > 0 || soap_flag_IsLottery1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__AwardInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AwardInfo);
	if (this->soap_out(soap, tag?tag:"ns1:AwardInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AwardInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AwardInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AwardInfo * SOAP_FMAC4 soap_get_ns1__AwardInfo(struct soap *soap, ns1__AwardInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AwardInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__AwardInfo * SOAP_FMAC2 soap_instantiate_ns1__AwardInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AwardInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AwardInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__AwardInfo);
		if (size)
			*size = sizeof(ns1__AwardInfo);
		((ns1__AwardInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__AwardInfo, n);
		if (size)
			*size = n * sizeof(ns1__AwardInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__AwardInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__AwardInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AwardInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AwardInfo %p -> %p\n", q, p));
	*(ns1__AwardInfo*)p = *(ns1__AwardInfo*)q;
}

void ns1__AwardItemInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__AwardItemInfo::ID);
	soap_default_int(soap, &this->ns1__AwardItemInfo::AwardID);
	soap_default_int(soap, &this->ns1__AwardItemInfo::ItemID);
	soap_default_int(soap, &this->ns1__AwardItemInfo::UnitID);
	soap_default_int(soap, &this->ns1__AwardItemInfo::TotalNumber);
	soap_default_int(soap, &this->ns1__AwardItemInfo::EachNumber);
	soap_default_int(soap, &this->ns1__AwardItemInfo::AwardedNumber);
	soap_default_time(soap, &this->ns1__AwardItemInfo::ExpiryTime);
	soap_default_int(soap, &this->ns1__AwardItemInfo::ExpiryDays);
	soap_default_int(soap, &this->ns1__AwardItemInfo::GiftTimes);
	soap_default_string(soap, &this->ns1__AwardItemInfo::ItemName);
	soap_default_string(soap, &this->ns1__AwardItemInfo::ItemCode);
	soap_default_string(soap, &this->ns1__AwardItemInfo::UnitName);
	soap_default_string(soap, &this->ns1__AwardItemInfo::ItemImage);
	soap_default_xsd__decimal(soap, &this->ns1__AwardItemInfo::AwardedItemValue);
	/* transient soap skipped */
}

void ns1__AwardItemInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__AwardItemInfo::ItemName);
	soap_serialize_string(soap, &this->ns1__AwardItemInfo::ItemCode);
	soap_serialize_string(soap, &this->ns1__AwardItemInfo::UnitName);
	soap_serialize_string(soap, &this->ns1__AwardItemInfo::ItemImage);
	soap_serialize_xsd__decimal(soap, &this->ns1__AwardItemInfo::AwardedItemValue);
	/* transient soap skipped */
#endif
}

int ns1__AwardItemInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AwardItemInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AwardItemInfo(struct soap *soap, const char *tag, int id, const ns1__AwardItemInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AwardItemInfo), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:ID", -1, &(a->ns1__AwardItemInfo::ID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:AwardID", -1, &(a->ns1__AwardItemInfo::AwardID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ItemID", -1, &(a->ns1__AwardItemInfo::ItemID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:UnitID", -1, &(a->ns1__AwardItemInfo::UnitID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:TotalNumber", -1, &(a->ns1__AwardItemInfo::TotalNumber), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:EachNumber", -1, &(a->ns1__AwardItemInfo::EachNumber), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:AwardedNumber", -1, &(a->ns1__AwardItemInfo::AwardedNumber), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:ExpiryTime", -1, &(a->ns1__AwardItemInfo::ExpiryTime), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ExpiryDays", -1, &(a->ns1__AwardItemInfo::ExpiryDays), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:GiftTimes", -1, &(a->ns1__AwardItemInfo::GiftTimes), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ItemName", -1, &(a->ns1__AwardItemInfo::ItemName), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ItemCode", -1, &(a->ns1__AwardItemInfo::ItemCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UnitName", -1, &(a->ns1__AwardItemInfo::UnitName), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ItemImage", -1, &(a->ns1__AwardItemInfo::ItemImage), ""))
		return soap->error;
	if (a->ns1__AwardItemInfo::AwardedItemValue)
	{	if (soap_out_xsd__decimal(soap, "ns1:AwardedItemValue", -1, &a->ns1__AwardItemInfo::AwardedItemValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:AwardedItemValue"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AwardItemInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AwardItemInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AwardItemInfo * SOAP_FMAC4 soap_in_ns1__AwardItemInfo(struct soap *soap, const char *tag, ns1__AwardItemInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AwardItemInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AwardItemInfo, sizeof(ns1__AwardItemInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AwardItemInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AwardItemInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_AwardID1 = 1;
	size_t soap_flag_ItemID1 = 1;
	size_t soap_flag_UnitID1 = 1;
	size_t soap_flag_TotalNumber1 = 1;
	size_t soap_flag_EachNumber1 = 1;
	size_t soap_flag_AwardedNumber1 = 1;
	size_t soap_flag_ExpiryTime1 = 1;
	size_t soap_flag_ExpiryDays1 = 1;
	size_t soap_flag_GiftTimes1 = 1;
	size_t soap_flag_ItemName1 = 1;
	size_t soap_flag_ItemCode1 = 1;
	size_t soap_flag_UnitName1 = 1;
	size_t soap_flag_ItemImage1 = 1;
	size_t soap_flag_AwardedItemValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ID", &(a->ns1__AwardItemInfo::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_AwardID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:AwardID", &(a->ns1__AwardItemInfo::AwardID), "xsd:int"))
				{	soap_flag_AwardID1--;
					continue;
				}
			if (soap_flag_ItemID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ItemID", &(a->ns1__AwardItemInfo::ItemID), "xsd:int"))
				{	soap_flag_ItemID1--;
					continue;
				}
			if (soap_flag_UnitID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:UnitID", &(a->ns1__AwardItemInfo::UnitID), "xsd:int"))
				{	soap_flag_UnitID1--;
					continue;
				}
			if (soap_flag_TotalNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:TotalNumber", &(a->ns1__AwardItemInfo::TotalNumber), "xsd:int"))
				{	soap_flag_TotalNumber1--;
					continue;
				}
			if (soap_flag_EachNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:EachNumber", &(a->ns1__AwardItemInfo::EachNumber), "xsd:int"))
				{	soap_flag_EachNumber1--;
					continue;
				}
			if (soap_flag_AwardedNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:AwardedNumber", &(a->ns1__AwardItemInfo::AwardedNumber), "xsd:int"))
				{	soap_flag_AwardedNumber1--;
					continue;
				}
			if (soap_flag_ExpiryTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:ExpiryTime", &(a->ns1__AwardItemInfo::ExpiryTime), "xsd:dateTime"))
				{	soap_flag_ExpiryTime1--;
					continue;
				}
			if (soap_flag_ExpiryDays1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ExpiryDays", &(a->ns1__AwardItemInfo::ExpiryDays), "xsd:int"))
				{	soap_flag_ExpiryDays1--;
					continue;
				}
			if (soap_flag_GiftTimes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:GiftTimes", &(a->ns1__AwardItemInfo::GiftTimes), "xsd:int"))
				{	soap_flag_GiftTimes1--;
					continue;
				}
			if (soap_flag_ItemName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ItemName", &(a->ns1__AwardItemInfo::ItemName), "xsd:string"))
				{	soap_flag_ItemName1--;
					continue;
				}
			if (soap_flag_ItemCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ItemCode", &(a->ns1__AwardItemInfo::ItemCode), "xsd:string"))
				{	soap_flag_ItemCode1--;
					continue;
				}
			if (soap_flag_UnitName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UnitName", &(a->ns1__AwardItemInfo::UnitName), "xsd:string"))
				{	soap_flag_UnitName1--;
					continue;
				}
			if (soap_flag_ItemImage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ItemImage", &(a->ns1__AwardItemInfo::ItemImage), "xsd:string"))
				{	soap_flag_ItemImage1--;
					continue;
				}
			if (soap_flag_AwardedItemValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:AwardedItemValue", &(a->ns1__AwardItemInfo::AwardedItemValue), "xsd:decimal"))
				{	soap_flag_AwardedItemValue1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AwardItemInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AwardItemInfo, 0, sizeof(ns1__AwardItemInfo), 0, soap_copy_ns1__AwardItemInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_AwardID1 > 0 || soap_flag_ItemID1 > 0 || soap_flag_UnitID1 > 0 || soap_flag_TotalNumber1 > 0 || soap_flag_EachNumber1 > 0 || soap_flag_AwardedNumber1 > 0 || soap_flag_ExpiryTime1 > 0 || soap_flag_ExpiryDays1 > 0 || soap_flag_GiftTimes1 > 0 || soap_flag_AwardedItemValue1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__AwardItemInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AwardItemInfo);
	if (this->soap_out(soap, tag?tag:"ns1:AwardItemInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AwardItemInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AwardItemInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AwardItemInfo * SOAP_FMAC4 soap_get_ns1__AwardItemInfo(struct soap *soap, ns1__AwardItemInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AwardItemInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__AwardItemInfo * SOAP_FMAC2 soap_instantiate_ns1__AwardItemInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AwardItemInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AwardItemInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__AwardItemInfo);
		if (size)
			*size = sizeof(ns1__AwardItemInfo);
		((ns1__AwardItemInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__AwardItemInfo, n);
		if (size)
			*size = n * sizeof(ns1__AwardItemInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__AwardItemInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__AwardItemInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AwardItemInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AwardItemInfo %p -> %p\n", q, p));
	*(ns1__AwardItemInfo*)p = *(ns1__AwardItemInfo*)q;
}

void ns1__ArrayOfAwardItemInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ArrayOfAwardItemInfo::__sizeAwardItemInfo = 0;
	this->ns1__ArrayOfAwardItemInfo::AwardItemInfo = NULL;
	/* transient soap skipped */
}

void ns1__ArrayOfAwardItemInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__ArrayOfAwardItemInfo::AwardItemInfo)
	{	int i;
		for (i = 0; i < this->ns1__ArrayOfAwardItemInfo::__sizeAwardItemInfo; i++)
		{
			soap_serialize_PointerTons1__AwardItemInfo(soap, this->ns1__ArrayOfAwardItemInfo::AwardItemInfo + i);
		}
	}
	/* transient soap skipped */
#endif
}

int ns1__ArrayOfAwardItemInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfAwardItemInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfAwardItemInfo(struct soap *soap, const char *tag, int id, const ns1__ArrayOfAwardItemInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfAwardItemInfo), type))
		return soap->error;
	if (a->ns1__ArrayOfAwardItemInfo::AwardItemInfo)
	{	int i;
		for (i = 0; i < a->ns1__ArrayOfAwardItemInfo::__sizeAwardItemInfo; i++)
			if (soap_out_PointerTons1__AwardItemInfo(soap, "ns1:AwardItemInfo", -1, a->ns1__ArrayOfAwardItemInfo::AwardItemInfo + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfAwardItemInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfAwardItemInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfAwardItemInfo * SOAP_FMAC4 soap_in_ns1__ArrayOfAwardItemInfo(struct soap *soap, const char *tag, ns1__ArrayOfAwardItemInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfAwardItemInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfAwardItemInfo, sizeof(ns1__ArrayOfAwardItemInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfAwardItemInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfAwardItemInfo *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_AwardItemInfo1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:AwardItemInfo", 1, NULL))
			{	if (a->ns1__ArrayOfAwardItemInfo::AwardItemInfo == NULL)
				{	if (soap_blist_AwardItemInfo1 == NULL)
						soap_blist_AwardItemInfo1 = soap_new_block(soap);
					a->ns1__ArrayOfAwardItemInfo::AwardItemInfo = (ns1__AwardItemInfo **)soap_push_block(soap, soap_blist_AwardItemInfo1, sizeof(ns1__AwardItemInfo *));
					if (a->ns1__ArrayOfAwardItemInfo::AwardItemInfo == NULL)
						return NULL;
					*a->ns1__ArrayOfAwardItemInfo::AwardItemInfo = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__AwardItemInfo(soap, "ns1:AwardItemInfo", a->ns1__ArrayOfAwardItemInfo::AwardItemInfo, "ns1:AwardItemInfo"))
				{	a->ns1__ArrayOfAwardItemInfo::__sizeAwardItemInfo++;
					a->ns1__ArrayOfAwardItemInfo::AwardItemInfo = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__ArrayOfAwardItemInfo::AwardItemInfo)
			soap_pop_block(soap, soap_blist_AwardItemInfo1);
		if (a->ns1__ArrayOfAwardItemInfo::__sizeAwardItemInfo)
			a->ns1__ArrayOfAwardItemInfo::AwardItemInfo = (ns1__AwardItemInfo **)soap_save_block(soap, soap_blist_AwardItemInfo1, NULL, 1);
		else
		{	a->ns1__ArrayOfAwardItemInfo::AwardItemInfo = NULL;
			if (soap_blist_AwardItemInfo1)
				soap_end_block(soap, soap_blist_AwardItemInfo1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfAwardItemInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfAwardItemInfo, 0, sizeof(ns1__ArrayOfAwardItemInfo), 0, soap_copy_ns1__ArrayOfAwardItemInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ArrayOfAwardItemInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfAwardItemInfo);
	if (this->soap_out(soap, tag?tag:"ns1:ArrayOfAwardItemInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfAwardItemInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfAwardItemInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfAwardItemInfo * SOAP_FMAC4 soap_get_ns1__ArrayOfAwardItemInfo(struct soap *soap, ns1__ArrayOfAwardItemInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfAwardItemInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ArrayOfAwardItemInfo * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfAwardItemInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfAwardItemInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfAwardItemInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ArrayOfAwardItemInfo);
		if (size)
			*size = sizeof(ns1__ArrayOfAwardItemInfo);
		((ns1__ArrayOfAwardItemInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__ArrayOfAwardItemInfo, n);
		if (size)
			*size = n * sizeof(ns1__ArrayOfAwardItemInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfAwardItemInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__ArrayOfAwardItemInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfAwardItemInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfAwardItemInfo %p -> %p\n", q, p));
	*(ns1__ArrayOfAwardItemInfo*)p = *(ns1__ArrayOfAwardItemInfo*)q;
}

void ns1__ItemInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__ItemInfo::ItemID);
	soap_default_int(soap, &this->ns1__ItemInfo::KindID);
	soap_default_ns1__KindEnum(soap, &this->ns1__ItemInfo::KindEnumValue);
	soap_default_int(soap, &this->ns1__ItemInfo::ItemTypeID);
	soap_default_string(soap, &this->ns1__ItemInfo::ClassID);
	soap_default_ns1__ItemTypeEnum(soap, &this->ns1__ItemInfo::ItemTypeEnumValue);
	soap_default_int(soap, &this->ns1__ItemInfo::PlatformID);
	soap_default_string(soap, &this->ns1__ItemInfo::ItemName);
	soap_default_string(soap, &this->ns1__ItemInfo::ItemCode);
	soap_default_string(soap, &this->ns1__ItemInfo::Remark);
	soap_default_string(soap, &this->ns1__ItemInfo::Intro);
	soap_default_string(soap, &this->ns1__ItemInfo::Image);
	soap_default_int(soap, &this->ns1__ItemInfo::RarityValue);
	soap_default_int(soap, &this->ns1__ItemInfo::ExpiryDays);
	soap_default_time(soap, &this->ns1__ItemInfo::ExpiryTime);
	soap_default_bool(soap, &this->ns1__ItemInfo::IsDuration);
	soap_default_bool(soap, &this->ns1__ItemInfo::IsAllowRenewal);
	soap_default_bool(soap, &this->ns1__ItemInfo::IsUseInMall);
	soap_default_bool(soap, &this->ns1__ItemInfo::IsAllowPawn);
	soap_default_bool(soap, &this->ns1__ItemInfo::IsAllowDoff);
	soap_default_bool(soap, &this->ns1__ItemInfo::IsMemberUse);
	soap_default_bool(soap, &this->ns1__ItemInfo::IsOnlyGiveMember);
	soap_default_int(soap, &this->ns1__ItemInfo::GiftTimes);
	soap_default_int(soap, &this->ns1__ItemInfo::UseExperienceLevel);
	soap_default_string(soap, &this->ns1__ItemInfo::PropertyValue);
	soap_default_string(soap, &this->ns1__ItemInfo::PropertyText);
	soap_default_string(soap, &this->ns1__ItemInfo::UseText);
	soap_default_string(soap, &this->ns1__ItemInfo::UseUrl);
	soap_default_string(soap, &this->ns1__ItemInfo::UseOpenType);
	soap_default_xsd__decimal(soap, &this->ns1__ItemInfo::ItemValue);
	soap_default_bool(soap, &this->ns1__ItemInfo::IsStop);
	soap_default_time(soap, &this->ns1__ItemInfo::LastUpdateTime);
	soap_default_int(soap, &this->ns1__ItemInfo::AdminID);
	soap_default_int(soap, &this->ns1__ItemInfo::GiveLevel);
	soap_default_string(soap, &this->ns1__ItemInfo::UnitID);
	soap_default_int(soap, &this->ns1__ItemInfo::ItemValueUnitID);
	/* transient soap skipped */
}

void ns1__ItemInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__ItemInfo::ClassID);
	soap_serialize_string(soap, &this->ns1__ItemInfo::ItemName);
	soap_serialize_string(soap, &this->ns1__ItemInfo::ItemCode);
	soap_serialize_string(soap, &this->ns1__ItemInfo::Remark);
	soap_serialize_string(soap, &this->ns1__ItemInfo::Intro);
	soap_serialize_string(soap, &this->ns1__ItemInfo::Image);
	soap_serialize_string(soap, &this->ns1__ItemInfo::PropertyValue);
	soap_serialize_string(soap, &this->ns1__ItemInfo::PropertyText);
	soap_serialize_string(soap, &this->ns1__ItemInfo::UseText);
	soap_serialize_string(soap, &this->ns1__ItemInfo::UseUrl);
	soap_serialize_string(soap, &this->ns1__ItemInfo::UseOpenType);
	soap_serialize_xsd__decimal(soap, &this->ns1__ItemInfo::ItemValue);
	soap_serialize_string(soap, &this->ns1__ItemInfo::UnitID);
	/* transient soap skipped */
#endif
}

int ns1__ItemInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ItemInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemInfo(struct soap *soap, const char *tag, int id, const ns1__ItemInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemInfo), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:ItemID", -1, &(a->ns1__ItemInfo::ItemID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:KindID", -1, &(a->ns1__ItemInfo::KindID), ""))
		return soap->error;
	if (soap_out_ns1__KindEnum(soap, "ns1:KindEnumValue", -1, &(a->ns1__ItemInfo::KindEnumValue), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ItemTypeID", -1, &(a->ns1__ItemInfo::ItemTypeID), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ClassID", -1, &(a->ns1__ItemInfo::ClassID), ""))
		return soap->error;
	if (soap_out_ns1__ItemTypeEnum(soap, "ns1:ItemTypeEnumValue", -1, &(a->ns1__ItemInfo::ItemTypeEnumValue), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PlatformID", -1, &(a->ns1__ItemInfo::PlatformID), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ItemName", -1, &(a->ns1__ItemInfo::ItemName), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ItemCode", -1, &(a->ns1__ItemInfo::ItemCode), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Remark", -1, &(a->ns1__ItemInfo::Remark), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Intro", -1, &(a->ns1__ItemInfo::Intro), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Image", -1, &(a->ns1__ItemInfo::Image), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:RarityValue", -1, &(a->ns1__ItemInfo::RarityValue), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ExpiryDays", -1, &(a->ns1__ItemInfo::ExpiryDays), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:ExpiryTime", -1, &(a->ns1__ItemInfo::ExpiryTime), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsDuration", -1, &(a->ns1__ItemInfo::IsDuration), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsAllowRenewal", -1, &(a->ns1__ItemInfo::IsAllowRenewal), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsUseInMall", -1, &(a->ns1__ItemInfo::IsUseInMall), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsAllowPawn", -1, &(a->ns1__ItemInfo::IsAllowPawn), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsAllowDoff", -1, &(a->ns1__ItemInfo::IsAllowDoff), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsMemberUse", -1, &(a->ns1__ItemInfo::IsMemberUse), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsOnlyGiveMember", -1, &(a->ns1__ItemInfo::IsOnlyGiveMember), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:GiftTimes", -1, &(a->ns1__ItemInfo::GiftTimes), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:UseExperienceLevel", -1, &(a->ns1__ItemInfo::UseExperienceLevel), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:PropertyValue", -1, &(a->ns1__ItemInfo::PropertyValue), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:PropertyText", -1, &(a->ns1__ItemInfo::PropertyText), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UseText", -1, &(a->ns1__ItemInfo::UseText), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UseUrl", -1, &(a->ns1__ItemInfo::UseUrl), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UseOpenType", -1, &(a->ns1__ItemInfo::UseOpenType), ""))
		return soap->error;
	if (a->ns1__ItemInfo::ItemValue)
	{	if (soap_out_xsd__decimal(soap, "ns1:ItemValue", -1, &a->ns1__ItemInfo::ItemValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:ItemValue"))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsStop", -1, &(a->ns1__ItemInfo::IsStop), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:LastUpdateTime", -1, &(a->ns1__ItemInfo::LastUpdateTime), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:AdminID", -1, &(a->ns1__ItemInfo::AdminID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:GiveLevel", -1, &(a->ns1__ItemInfo::GiveLevel), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UnitID", -1, &(a->ns1__ItemInfo::UnitID), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ItemValueUnitID", -1, &(a->ns1__ItemInfo::ItemValueUnitID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ItemInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ItemInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ItemInfo * SOAP_FMAC4 soap_in_ns1__ItemInfo(struct soap *soap, const char *tag, ns1__ItemInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ItemInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemInfo, sizeof(ns1__ItemInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ItemInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ItemInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ItemID1 = 1;
	size_t soap_flag_KindID1 = 1;
	size_t soap_flag_KindEnumValue1 = 1;
	size_t soap_flag_ItemTypeID1 = 1;
	size_t soap_flag_ClassID1 = 1;
	size_t soap_flag_ItemTypeEnumValue1 = 1;
	size_t soap_flag_PlatformID1 = 1;
	size_t soap_flag_ItemName1 = 1;
	size_t soap_flag_ItemCode1 = 1;
	size_t soap_flag_Remark1 = 1;
	size_t soap_flag_Intro1 = 1;
	size_t soap_flag_Image1 = 1;
	size_t soap_flag_RarityValue1 = 1;
	size_t soap_flag_ExpiryDays1 = 1;
	size_t soap_flag_ExpiryTime1 = 1;
	size_t soap_flag_IsDuration1 = 1;
	size_t soap_flag_IsAllowRenewal1 = 1;
	size_t soap_flag_IsUseInMall1 = 1;
	size_t soap_flag_IsAllowPawn1 = 1;
	size_t soap_flag_IsAllowDoff1 = 1;
	size_t soap_flag_IsMemberUse1 = 1;
	size_t soap_flag_IsOnlyGiveMember1 = 1;
	size_t soap_flag_GiftTimes1 = 1;
	size_t soap_flag_UseExperienceLevel1 = 1;
	size_t soap_flag_PropertyValue1 = 1;
	size_t soap_flag_PropertyText1 = 1;
	size_t soap_flag_UseText1 = 1;
	size_t soap_flag_UseUrl1 = 1;
	size_t soap_flag_UseOpenType1 = 1;
	size_t soap_flag_ItemValue1 = 1;
	size_t soap_flag_IsStop1 = 1;
	size_t soap_flag_LastUpdateTime1 = 1;
	size_t soap_flag_AdminID1 = 1;
	size_t soap_flag_GiveLevel1 = 1;
	size_t soap_flag_UnitID1 = 1;
	size_t soap_flag_ItemValueUnitID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ItemID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ItemID", &(a->ns1__ItemInfo::ItemID), "xsd:int"))
				{	soap_flag_ItemID1--;
					continue;
				}
			if (soap_flag_KindID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:KindID", &(a->ns1__ItemInfo::KindID), "xsd:int"))
				{	soap_flag_KindID1--;
					continue;
				}
			if (soap_flag_KindEnumValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__KindEnum(soap, "ns1:KindEnumValue", &(a->ns1__ItemInfo::KindEnumValue), "ns1:KindEnum"))
				{	soap_flag_KindEnumValue1--;
					continue;
				}
			if (soap_flag_ItemTypeID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ItemTypeID", &(a->ns1__ItemInfo::ItemTypeID), "xsd:int"))
				{	soap_flag_ItemTypeID1--;
					continue;
				}
			if (soap_flag_ClassID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ClassID", &(a->ns1__ItemInfo::ClassID), "xsd:string"))
				{	soap_flag_ClassID1--;
					continue;
				}
			if (soap_flag_ItemTypeEnumValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__ItemTypeEnum(soap, "ns1:ItemTypeEnumValue", &(a->ns1__ItemInfo::ItemTypeEnumValue), "ns1:ItemTypeEnum"))
				{	soap_flag_ItemTypeEnumValue1--;
					continue;
				}
			if (soap_flag_PlatformID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PlatformID", &(a->ns1__ItemInfo::PlatformID), "xsd:int"))
				{	soap_flag_PlatformID1--;
					continue;
				}
			if (soap_flag_ItemName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ItemName", &(a->ns1__ItemInfo::ItemName), "xsd:string"))
				{	soap_flag_ItemName1--;
					continue;
				}
			if (soap_flag_ItemCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ItemCode", &(a->ns1__ItemInfo::ItemCode), "xsd:string"))
				{	soap_flag_ItemCode1--;
					continue;
				}
			if (soap_flag_Remark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Remark", &(a->ns1__ItemInfo::Remark), "xsd:string"))
				{	soap_flag_Remark1--;
					continue;
				}
			if (soap_flag_Intro1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Intro", &(a->ns1__ItemInfo::Intro), "xsd:string"))
				{	soap_flag_Intro1--;
					continue;
				}
			if (soap_flag_Image1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Image", &(a->ns1__ItemInfo::Image), "xsd:string"))
				{	soap_flag_Image1--;
					continue;
				}
			if (soap_flag_RarityValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:RarityValue", &(a->ns1__ItemInfo::RarityValue), "xsd:int"))
				{	soap_flag_RarityValue1--;
					continue;
				}
			if (soap_flag_ExpiryDays1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ExpiryDays", &(a->ns1__ItemInfo::ExpiryDays), "xsd:int"))
				{	soap_flag_ExpiryDays1--;
					continue;
				}
			if (soap_flag_ExpiryTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:ExpiryTime", &(a->ns1__ItemInfo::ExpiryTime), "xsd:dateTime"))
				{	soap_flag_ExpiryTime1--;
					continue;
				}
			if (soap_flag_IsDuration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IsDuration", &(a->ns1__ItemInfo::IsDuration), "xsd:boolean"))
				{	soap_flag_IsDuration1--;
					continue;
				}
			if (soap_flag_IsAllowRenewal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IsAllowRenewal", &(a->ns1__ItemInfo::IsAllowRenewal), "xsd:boolean"))
				{	soap_flag_IsAllowRenewal1--;
					continue;
				}
			if (soap_flag_IsUseInMall1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IsUseInMall", &(a->ns1__ItemInfo::IsUseInMall), "xsd:boolean"))
				{	soap_flag_IsUseInMall1--;
					continue;
				}
			if (soap_flag_IsAllowPawn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IsAllowPawn", &(a->ns1__ItemInfo::IsAllowPawn), "xsd:boolean"))
				{	soap_flag_IsAllowPawn1--;
					continue;
				}
			if (soap_flag_IsAllowDoff1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IsAllowDoff", &(a->ns1__ItemInfo::IsAllowDoff), "xsd:boolean"))
				{	soap_flag_IsAllowDoff1--;
					continue;
				}
			if (soap_flag_IsMemberUse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IsMemberUse", &(a->ns1__ItemInfo::IsMemberUse), "xsd:boolean"))
				{	soap_flag_IsMemberUse1--;
					continue;
				}
			if (soap_flag_IsOnlyGiveMember1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IsOnlyGiveMember", &(a->ns1__ItemInfo::IsOnlyGiveMember), "xsd:boolean"))
				{	soap_flag_IsOnlyGiveMember1--;
					continue;
				}
			if (soap_flag_GiftTimes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:GiftTimes", &(a->ns1__ItemInfo::GiftTimes), "xsd:int"))
				{	soap_flag_GiftTimes1--;
					continue;
				}
			if (soap_flag_UseExperienceLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:UseExperienceLevel", &(a->ns1__ItemInfo::UseExperienceLevel), "xsd:int"))
				{	soap_flag_UseExperienceLevel1--;
					continue;
				}
			if (soap_flag_PropertyValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PropertyValue", &(a->ns1__ItemInfo::PropertyValue), "xsd:string"))
				{	soap_flag_PropertyValue1--;
					continue;
				}
			if (soap_flag_PropertyText1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PropertyText", &(a->ns1__ItemInfo::PropertyText), "xsd:string"))
				{	soap_flag_PropertyText1--;
					continue;
				}
			if (soap_flag_UseText1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UseText", &(a->ns1__ItemInfo::UseText), "xsd:string"))
				{	soap_flag_UseText1--;
					continue;
				}
			if (soap_flag_UseUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UseUrl", &(a->ns1__ItemInfo::UseUrl), "xsd:string"))
				{	soap_flag_UseUrl1--;
					continue;
				}
			if (soap_flag_UseOpenType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UseOpenType", &(a->ns1__ItemInfo::UseOpenType), "xsd:string"))
				{	soap_flag_UseOpenType1--;
					continue;
				}
			if (soap_flag_ItemValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "ns1:ItemValue", &(a->ns1__ItemInfo::ItemValue), "xsd:decimal"))
				{	soap_flag_ItemValue1--;
					continue;
				}
			if (soap_flag_IsStop1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IsStop", &(a->ns1__ItemInfo::IsStop), "xsd:boolean"))
				{	soap_flag_IsStop1--;
					continue;
				}
			if (soap_flag_LastUpdateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:LastUpdateTime", &(a->ns1__ItemInfo::LastUpdateTime), "xsd:dateTime"))
				{	soap_flag_LastUpdateTime1--;
					continue;
				}
			if (soap_flag_AdminID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:AdminID", &(a->ns1__ItemInfo::AdminID), "xsd:int"))
				{	soap_flag_AdminID1--;
					continue;
				}
			if (soap_flag_GiveLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:GiveLevel", &(a->ns1__ItemInfo::GiveLevel), "xsd:int"))
				{	soap_flag_GiveLevel1--;
					continue;
				}
			if (soap_flag_UnitID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UnitID", &(a->ns1__ItemInfo::UnitID), "xsd:string"))
				{	soap_flag_UnitID1--;
					continue;
				}
			if (soap_flag_ItemValueUnitID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ItemValueUnitID", &(a->ns1__ItemInfo::ItemValueUnitID), "xsd:int"))
				{	soap_flag_ItemValueUnitID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ItemInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ItemInfo, 0, sizeof(ns1__ItemInfo), 0, soap_copy_ns1__ItemInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ItemID1 > 0 || soap_flag_KindID1 > 0 || soap_flag_KindEnumValue1 > 0 || soap_flag_ItemTypeID1 > 0 || soap_flag_ItemTypeEnumValue1 > 0 || soap_flag_PlatformID1 > 0 || soap_flag_RarityValue1 > 0 || soap_flag_ExpiryDays1 > 0 || soap_flag_ExpiryTime1 > 0 || soap_flag_IsDuration1 > 0 || soap_flag_IsAllowRenewal1 > 0 || soap_flag_IsUseInMall1 > 0 || soap_flag_IsAllowPawn1 > 0 || soap_flag_IsAllowDoff1 > 0 || soap_flag_IsMemberUse1 > 0 || soap_flag_IsOnlyGiveMember1 > 0 || soap_flag_GiftTimes1 > 0 || soap_flag_UseExperienceLevel1 > 0 || soap_flag_ItemValue1 > 0 || soap_flag_IsStop1 > 0 || soap_flag_LastUpdateTime1 > 0 || soap_flag_AdminID1 > 0 || soap_flag_GiveLevel1 > 0 || soap_flag_ItemValueUnitID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ItemInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ItemInfo);
	if (this->soap_out(soap, tag?tag:"ns1:ItemInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ItemInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ItemInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ItemInfo * SOAP_FMAC4 soap_get_ns1__ItemInfo(struct soap *soap, ns1__ItemInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ItemInfo * SOAP_FMAC2 soap_instantiate_ns1__ItemInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ItemInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ItemInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ItemInfo);
		if (size)
			*size = sizeof(ns1__ItemInfo);
		((ns1__ItemInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__ItemInfo, n);
		if (size)
			*size = n * sizeof(ns1__ItemInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__ItemInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__ItemInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ItemInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ItemInfo %p -> %p\n", q, p));
	*(ns1__ItemInfo*)p = *(ns1__ItemInfo*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLotteryWinningList_(struct soap *soap, struct __ns1__GetLotteryWinningList_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLotteryWinningList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLotteryWinningList_(struct soap *soap, const struct __ns1__GetLotteryWinningList_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLotteryWinningList(soap, &a->ns1__GetLotteryWinningList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLotteryWinningList_(struct soap *soap, const char *tag, int id, const struct __ns1__GetLotteryWinningList_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetLotteryWinningList(soap, "ns1:GetLotteryWinningList", -1, &a->ns1__GetLotteryWinningList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotteryWinningList_ * SOAP_FMAC4 soap_in___ns1__GetLotteryWinningList_(struct soap *soap, const char *tag, struct __ns1__GetLotteryWinningList_ *a, const char *type)
{
	size_t soap_flag_ns1__GetLotteryWinningList = 1;
	short soap_flag;
	a = (struct __ns1__GetLotteryWinningList_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLotteryWinningList_, sizeof(struct __ns1__GetLotteryWinningList_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLotteryWinningList_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLotteryWinningList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLotteryWinningList(soap, "ns1:GetLotteryWinningList", &a->ns1__GetLotteryWinningList, ""))
				{	soap_flag_ns1__GetLotteryWinningList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLotteryWinningList_(struct soap *soap, const struct __ns1__GetLotteryWinningList_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLotteryWinningList_(soap, tag?tag:"-ns1:GetLotteryWinningList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotteryWinningList_ * SOAP_FMAC4 soap_get___ns1__GetLotteryWinningList_(struct soap *soap, struct __ns1__GetLotteryWinningList_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLotteryWinningList_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetLotteryWinningList_ * SOAP_FMAC2 soap_instantiate___ns1__GetLotteryWinningList_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLotteryWinningList_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetLotteryWinningList_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetLotteryWinningList_);
		if (size)
			*size = sizeof(struct __ns1__GetLotteryWinningList_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetLotteryWinningList_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetLotteryWinningList_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetLotteryWinningList_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetLotteryWinningList_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetLotteryWinningList_ %p -> %p\n", q, p));
	*(struct __ns1__GetLotteryWinningList_*)p = *(struct __ns1__GetLotteryWinningList_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLotteryWinningTop_(struct soap *soap, struct __ns1__GetLotteryWinningTop_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLotteryWinningTop = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLotteryWinningTop_(struct soap *soap, const struct __ns1__GetLotteryWinningTop_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLotteryWinningTop(soap, &a->ns1__GetLotteryWinningTop);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLotteryWinningTop_(struct soap *soap, const char *tag, int id, const struct __ns1__GetLotteryWinningTop_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetLotteryWinningTop(soap, "ns1:GetLotteryWinningTop", -1, &a->ns1__GetLotteryWinningTop, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotteryWinningTop_ * SOAP_FMAC4 soap_in___ns1__GetLotteryWinningTop_(struct soap *soap, const char *tag, struct __ns1__GetLotteryWinningTop_ *a, const char *type)
{
	size_t soap_flag_ns1__GetLotteryWinningTop = 1;
	short soap_flag;
	a = (struct __ns1__GetLotteryWinningTop_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLotteryWinningTop_, sizeof(struct __ns1__GetLotteryWinningTop_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLotteryWinningTop_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLotteryWinningTop && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLotteryWinningTop(soap, "ns1:GetLotteryWinningTop", &a->ns1__GetLotteryWinningTop, ""))
				{	soap_flag_ns1__GetLotteryWinningTop--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLotteryWinningTop_(struct soap *soap, const struct __ns1__GetLotteryWinningTop_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLotteryWinningTop_(soap, tag?tag:"-ns1:GetLotteryWinningTop", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotteryWinningTop_ * SOAP_FMAC4 soap_get___ns1__GetLotteryWinningTop_(struct soap *soap, struct __ns1__GetLotteryWinningTop_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLotteryWinningTop_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetLotteryWinningTop_ * SOAP_FMAC2 soap_instantiate___ns1__GetLotteryWinningTop_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLotteryWinningTop_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetLotteryWinningTop_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetLotteryWinningTop_);
		if (size)
			*size = sizeof(struct __ns1__GetLotteryWinningTop_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetLotteryWinningTop_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetLotteryWinningTop_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetLotteryWinningTop_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetLotteryWinningTop_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetLotteryWinningTop_ %p -> %p\n", q, p));
	*(struct __ns1__GetLotteryWinningTop_*)p = *(struct __ns1__GetLotteryWinningTop_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLotteryPrize_(struct soap *soap, struct __ns1__GetLotteryPrize_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLotteryPrize = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLotteryPrize_(struct soap *soap, const struct __ns1__GetLotteryPrize_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLotteryPrize(soap, &a->ns1__GetLotteryPrize);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLotteryPrize_(struct soap *soap, const char *tag, int id, const struct __ns1__GetLotteryPrize_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetLotteryPrize(soap, "ns1:GetLotteryPrize", -1, &a->ns1__GetLotteryPrize, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotteryPrize_ * SOAP_FMAC4 soap_in___ns1__GetLotteryPrize_(struct soap *soap, const char *tag, struct __ns1__GetLotteryPrize_ *a, const char *type)
{
	size_t soap_flag_ns1__GetLotteryPrize = 1;
	short soap_flag;
	a = (struct __ns1__GetLotteryPrize_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLotteryPrize_, sizeof(struct __ns1__GetLotteryPrize_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLotteryPrize_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLotteryPrize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLotteryPrize(soap, "ns1:GetLotteryPrize", &a->ns1__GetLotteryPrize, ""))
				{	soap_flag_ns1__GetLotteryPrize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLotteryPrize_(struct soap *soap, const struct __ns1__GetLotteryPrize_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLotteryPrize_(soap, tag?tag:"-ns1:GetLotteryPrize", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotteryPrize_ * SOAP_FMAC4 soap_get___ns1__GetLotteryPrize_(struct soap *soap, struct __ns1__GetLotteryPrize_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLotteryPrize_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetLotteryPrize_ * SOAP_FMAC2 soap_instantiate___ns1__GetLotteryPrize_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLotteryPrize_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetLotteryPrize_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetLotteryPrize_);
		if (size)
			*size = sizeof(struct __ns1__GetLotteryPrize_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetLotteryPrize_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetLotteryPrize_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetLotteryPrize_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetLotteryPrize_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetLotteryPrize_ %p -> %p\n", q, p));
	*(struct __ns1__GetLotteryPrize_*)p = *(struct __ns1__GetLotteryPrize_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Lottery_(struct soap *soap, struct __ns1__Lottery_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Lottery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Lottery_(struct soap *soap, const struct __ns1__Lottery_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Lottery(soap, &a->ns1__Lottery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Lottery_(struct soap *soap, const char *tag, int id, const struct __ns1__Lottery_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__Lottery(soap, "ns1:Lottery", -1, &a->ns1__Lottery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Lottery_ * SOAP_FMAC4 soap_in___ns1__Lottery_(struct soap *soap, const char *tag, struct __ns1__Lottery_ *a, const char *type)
{
	size_t soap_flag_ns1__Lottery = 1;
	short soap_flag;
	a = (struct __ns1__Lottery_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Lottery_, sizeof(struct __ns1__Lottery_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Lottery_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Lottery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Lottery(soap, "ns1:Lottery", &a->ns1__Lottery, ""))
				{	soap_flag_ns1__Lottery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Lottery_(struct soap *soap, const struct __ns1__Lottery_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Lottery_(soap, tag?tag:"-ns1:Lottery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Lottery_ * SOAP_FMAC4 soap_get___ns1__Lottery_(struct soap *soap, struct __ns1__Lottery_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Lottery_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__Lottery_ * SOAP_FMAC2 soap_instantiate___ns1__Lottery_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Lottery_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Lottery_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__Lottery_);
		if (size)
			*size = sizeof(struct __ns1__Lottery_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__Lottery_, n);
		if (size)
			*size = n * sizeof(struct __ns1__Lottery_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__Lottery_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Lottery_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Lottery_ %p -> %p\n", q, p));
	*(struct __ns1__Lottery_*)p = *(struct __ns1__Lottery_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAwardInfo_(struct soap *soap, struct __ns1__GetAwardInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAwardInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAwardInfo_(struct soap *soap, const struct __ns1__GetAwardInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAwardInfo(soap, &a->ns1__GetAwardInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAwardInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAwardInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAwardInfo(soap, "ns1:GetAwardInfo", -1, &a->ns1__GetAwardInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAwardInfo_ * SOAP_FMAC4 soap_in___ns1__GetAwardInfo_(struct soap *soap, const char *tag, struct __ns1__GetAwardInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAwardInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetAwardInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAwardInfo_, sizeof(struct __ns1__GetAwardInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAwardInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAwardInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAwardInfo(soap, "ns1:GetAwardInfo", &a->ns1__GetAwardInfo, ""))
				{	soap_flag_ns1__GetAwardInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAwardInfo_(struct soap *soap, const struct __ns1__GetAwardInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAwardInfo_(soap, tag?tag:"-ns1:GetAwardInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAwardInfo_ * SOAP_FMAC4 soap_get___ns1__GetAwardInfo_(struct soap *soap, struct __ns1__GetAwardInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAwardInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAwardInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetAwardInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAwardInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAwardInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAwardInfo_);
		if (size)
			*size = sizeof(struct __ns1__GetAwardInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAwardInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAwardInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAwardInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAwardInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAwardInfo_ %p -> %p\n", q, p));
	*(struct __ns1__GetAwardInfo_*)p = *(struct __ns1__GetAwardInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAwardItem_(struct soap *soap, struct __ns1__GetAwardItem_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAwardItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAwardItem_(struct soap *soap, const struct __ns1__GetAwardItem_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAwardItem(soap, &a->ns1__GetAwardItem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAwardItem_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAwardItem_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAwardItem(soap, "ns1:GetAwardItem", -1, &a->ns1__GetAwardItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAwardItem_ * SOAP_FMAC4 soap_in___ns1__GetAwardItem_(struct soap *soap, const char *tag, struct __ns1__GetAwardItem_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAwardItem = 1;
	short soap_flag;
	a = (struct __ns1__GetAwardItem_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAwardItem_, sizeof(struct __ns1__GetAwardItem_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAwardItem_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAwardItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAwardItem(soap, "ns1:GetAwardItem", &a->ns1__GetAwardItem, ""))
				{	soap_flag_ns1__GetAwardItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAwardItem_(struct soap *soap, const struct __ns1__GetAwardItem_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAwardItem_(soap, tag?tag:"-ns1:GetAwardItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAwardItem_ * SOAP_FMAC4 soap_get___ns1__GetAwardItem_(struct soap *soap, struct __ns1__GetAwardItem_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAwardItem_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAwardItem_ * SOAP_FMAC2 soap_instantiate___ns1__GetAwardItem_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAwardItem_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAwardItem_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAwardItem_);
		if (size)
			*size = sizeof(struct __ns1__GetAwardItem_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAwardItem_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAwardItem_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAwardItem_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAwardItem_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAwardItem_ %p -> %p\n", q, p));
	*(struct __ns1__GetAwardItem_*)p = *(struct __ns1__GetAwardItem_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AwardItem_(struct soap *soap, struct __ns1__AwardItem_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AwardItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AwardItem_(struct soap *soap, const struct __ns1__AwardItem_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AwardItem(soap, &a->ns1__AwardItem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AwardItem_(struct soap *soap, const char *tag, int id, const struct __ns1__AwardItem_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__AwardItem(soap, "ns1:AwardItem", -1, &a->ns1__AwardItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AwardItem_ * SOAP_FMAC4 soap_in___ns1__AwardItem_(struct soap *soap, const char *tag, struct __ns1__AwardItem_ *a, const char *type)
{
	size_t soap_flag_ns1__AwardItem = 1;
	short soap_flag;
	a = (struct __ns1__AwardItem_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__AwardItem_, sizeof(struct __ns1__AwardItem_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AwardItem_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AwardItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AwardItem(soap, "ns1:AwardItem", &a->ns1__AwardItem, ""))
				{	soap_flag_ns1__AwardItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AwardItem_(struct soap *soap, const struct __ns1__AwardItem_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__AwardItem_(soap, tag?tag:"-ns1:AwardItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AwardItem_ * SOAP_FMAC4 soap_get___ns1__AwardItem_(struct soap *soap, struct __ns1__AwardItem_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AwardItem_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__AwardItem_ * SOAP_FMAC2 soap_instantiate___ns1__AwardItem_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AwardItem_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__AwardItem_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__AwardItem_);
		if (size)
			*size = sizeof(struct __ns1__AwardItem_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__AwardItem_, n);
		if (size)
			*size = n * sizeof(struct __ns1__AwardItem_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__AwardItem_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__AwardItem_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__AwardItem_ %p -> %p\n", q, p));
	*(struct __ns1__AwardItem_*)p = *(struct __ns1__AwardItem_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetClothingID_(struct soap *soap, struct __ns1__GetClothingID_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetClothingID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetClothingID_(struct soap *soap, const struct __ns1__GetClothingID_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetClothingID(soap, &a->ns1__GetClothingID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetClothingID_(struct soap *soap, const char *tag, int id, const struct __ns1__GetClothingID_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetClothingID(soap, "ns1:GetClothingID", -1, &a->ns1__GetClothingID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetClothingID_ * SOAP_FMAC4 soap_in___ns1__GetClothingID_(struct soap *soap, const char *tag, struct __ns1__GetClothingID_ *a, const char *type)
{
	size_t soap_flag_ns1__GetClothingID = 1;
	short soap_flag;
	a = (struct __ns1__GetClothingID_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetClothingID_, sizeof(struct __ns1__GetClothingID_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetClothingID_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetClothingID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetClothingID(soap, "ns1:GetClothingID", &a->ns1__GetClothingID, ""))
				{	soap_flag_ns1__GetClothingID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetClothingID_(struct soap *soap, const struct __ns1__GetClothingID_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetClothingID_(soap, tag?tag:"-ns1:GetClothingID", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetClothingID_ * SOAP_FMAC4 soap_get___ns1__GetClothingID_(struct soap *soap, struct __ns1__GetClothingID_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetClothingID_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetClothingID_ * SOAP_FMAC2 soap_instantiate___ns1__GetClothingID_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetClothingID_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetClothingID_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetClothingID_);
		if (size)
			*size = sizeof(struct __ns1__GetClothingID_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetClothingID_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetClothingID_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetClothingID_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetClothingID_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetClothingID_ %p -> %p\n", q, p));
	*(struct __ns1__GetClothingID_*)p = *(struct __ns1__GetClothingID_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetItemValue_(struct soap *soap, struct __ns1__GetItemValue_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetItemValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetItemValue_(struct soap *soap, const struct __ns1__GetItemValue_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetItemValue(soap, &a->ns1__GetItemValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetItemValue_(struct soap *soap, const char *tag, int id, const struct __ns1__GetItemValue_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetItemValue(soap, "ns1:GetItemValue", -1, &a->ns1__GetItemValue, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetItemValue_ * SOAP_FMAC4 soap_in___ns1__GetItemValue_(struct soap *soap, const char *tag, struct __ns1__GetItemValue_ *a, const char *type)
{
	size_t soap_flag_ns1__GetItemValue = 1;
	short soap_flag;
	a = (struct __ns1__GetItemValue_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetItemValue_, sizeof(struct __ns1__GetItemValue_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetItemValue_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetItemValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetItemValue(soap, "ns1:GetItemValue", &a->ns1__GetItemValue, ""))
				{	soap_flag_ns1__GetItemValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetItemValue_(struct soap *soap, const struct __ns1__GetItemValue_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetItemValue_(soap, tag?tag:"-ns1:GetItemValue", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetItemValue_ * SOAP_FMAC4 soap_get___ns1__GetItemValue_(struct soap *soap, struct __ns1__GetItemValue_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetItemValue_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetItemValue_ * SOAP_FMAC2 soap_instantiate___ns1__GetItemValue_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetItemValue_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetItemValue_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetItemValue_);
		if (size)
			*size = sizeof(struct __ns1__GetItemValue_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetItemValue_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetItemValue_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetItemValue_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetItemValue_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetItemValue_ %p -> %p\n", q, p));
	*(struct __ns1__GetItemValue_*)p = *(struct __ns1__GetItemValue_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetItemByItemID_(struct soap *soap, struct __ns1__GetItemByItemID_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetItemByItemID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetItemByItemID_(struct soap *soap, const struct __ns1__GetItemByItemID_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetItemByItemID(soap, &a->ns1__GetItemByItemID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetItemByItemID_(struct soap *soap, const char *tag, int id, const struct __ns1__GetItemByItemID_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetItemByItemID(soap, "ns1:GetItemByItemID", -1, &a->ns1__GetItemByItemID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetItemByItemID_ * SOAP_FMAC4 soap_in___ns1__GetItemByItemID_(struct soap *soap, const char *tag, struct __ns1__GetItemByItemID_ *a, const char *type)
{
	size_t soap_flag_ns1__GetItemByItemID = 1;
	short soap_flag;
	a = (struct __ns1__GetItemByItemID_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetItemByItemID_, sizeof(struct __ns1__GetItemByItemID_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetItemByItemID_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetItemByItemID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetItemByItemID(soap, "ns1:GetItemByItemID", &a->ns1__GetItemByItemID, ""))
				{	soap_flag_ns1__GetItemByItemID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetItemByItemID_(struct soap *soap, const struct __ns1__GetItemByItemID_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetItemByItemID_(soap, tag?tag:"-ns1:GetItemByItemID", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetItemByItemID_ * SOAP_FMAC4 soap_get___ns1__GetItemByItemID_(struct soap *soap, struct __ns1__GetItemByItemID_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetItemByItemID_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetItemByItemID_ * SOAP_FMAC2 soap_instantiate___ns1__GetItemByItemID_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetItemByItemID_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetItemByItemID_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetItemByItemID_);
		if (size)
			*size = sizeof(struct __ns1__GetItemByItemID_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetItemByItemID_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetItemByItemID_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetItemByItemID_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetItemByItemID_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetItemByItemID_ %p -> %p\n", q, p));
	*(struct __ns1__GetItemByItemID_*)p = *(struct __ns1__GetItemByItemID_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetItemByCode_(struct soap *soap, struct __ns1__GetItemByCode_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetItemByCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetItemByCode_(struct soap *soap, const struct __ns1__GetItemByCode_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetItemByCode(soap, &a->ns1__GetItemByCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetItemByCode_(struct soap *soap, const char *tag, int id, const struct __ns1__GetItemByCode_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetItemByCode(soap, "ns1:GetItemByCode", -1, &a->ns1__GetItemByCode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetItemByCode_ * SOAP_FMAC4 soap_in___ns1__GetItemByCode_(struct soap *soap, const char *tag, struct __ns1__GetItemByCode_ *a, const char *type)
{
	size_t soap_flag_ns1__GetItemByCode = 1;
	short soap_flag;
	a = (struct __ns1__GetItemByCode_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetItemByCode_, sizeof(struct __ns1__GetItemByCode_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetItemByCode_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetItemByCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetItemByCode(soap, "ns1:GetItemByCode", &a->ns1__GetItemByCode, ""))
				{	soap_flag_ns1__GetItemByCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetItemByCode_(struct soap *soap, const struct __ns1__GetItemByCode_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetItemByCode_(soap, tag?tag:"-ns1:GetItemByCode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetItemByCode_ * SOAP_FMAC4 soap_get___ns1__GetItemByCode_(struct soap *soap, struct __ns1__GetItemByCode_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetItemByCode_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetItemByCode_ * SOAP_FMAC2 soap_instantiate___ns1__GetItemByCode_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetItemByCode_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetItemByCode_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetItemByCode_);
		if (size)
			*size = sizeof(struct __ns1__GetItemByCode_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetItemByCode_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetItemByCode_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetItemByCode_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetItemByCode_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetItemByCode_ %p -> %p\n", q, p));
	*(struct __ns1__GetItemByCode_*)p = *(struct __ns1__GetItemByCode_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLotteryWinningList(struct soap *soap, struct __ns1__GetLotteryWinningList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLotteryWinningList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLotteryWinningList(struct soap *soap, const struct __ns1__GetLotteryWinningList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLotteryWinningList(soap, &a->ns1__GetLotteryWinningList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLotteryWinningList(struct soap *soap, const char *tag, int id, const struct __ns1__GetLotteryWinningList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetLotteryWinningList(soap, "ns1:GetLotteryWinningList", -1, &a->ns1__GetLotteryWinningList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotteryWinningList * SOAP_FMAC4 soap_in___ns1__GetLotteryWinningList(struct soap *soap, const char *tag, struct __ns1__GetLotteryWinningList *a, const char *type)
{
	size_t soap_flag_ns1__GetLotteryWinningList = 1;
	short soap_flag;
	a = (struct __ns1__GetLotteryWinningList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLotteryWinningList, sizeof(struct __ns1__GetLotteryWinningList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLotteryWinningList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLotteryWinningList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLotteryWinningList(soap, "ns1:GetLotteryWinningList", &a->ns1__GetLotteryWinningList, ""))
				{	soap_flag_ns1__GetLotteryWinningList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLotteryWinningList(struct soap *soap, const struct __ns1__GetLotteryWinningList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLotteryWinningList(soap, tag?tag:"-ns1:GetLotteryWinningList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotteryWinningList * SOAP_FMAC4 soap_get___ns1__GetLotteryWinningList(struct soap *soap, struct __ns1__GetLotteryWinningList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLotteryWinningList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetLotteryWinningList * SOAP_FMAC2 soap_instantiate___ns1__GetLotteryWinningList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLotteryWinningList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetLotteryWinningList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetLotteryWinningList);
		if (size)
			*size = sizeof(struct __ns1__GetLotteryWinningList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetLotteryWinningList, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetLotteryWinningList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetLotteryWinningList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetLotteryWinningList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetLotteryWinningList %p -> %p\n", q, p));
	*(struct __ns1__GetLotteryWinningList*)p = *(struct __ns1__GetLotteryWinningList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLotteryWinningTop(struct soap *soap, struct __ns1__GetLotteryWinningTop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLotteryWinningTop = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLotteryWinningTop(struct soap *soap, const struct __ns1__GetLotteryWinningTop *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLotteryWinningTop(soap, &a->ns1__GetLotteryWinningTop);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLotteryWinningTop(struct soap *soap, const char *tag, int id, const struct __ns1__GetLotteryWinningTop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetLotteryWinningTop(soap, "ns1:GetLotteryWinningTop", -1, &a->ns1__GetLotteryWinningTop, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotteryWinningTop * SOAP_FMAC4 soap_in___ns1__GetLotteryWinningTop(struct soap *soap, const char *tag, struct __ns1__GetLotteryWinningTop *a, const char *type)
{
	size_t soap_flag_ns1__GetLotteryWinningTop = 1;
	short soap_flag;
	a = (struct __ns1__GetLotteryWinningTop *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLotteryWinningTop, sizeof(struct __ns1__GetLotteryWinningTop), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLotteryWinningTop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLotteryWinningTop && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLotteryWinningTop(soap, "ns1:GetLotteryWinningTop", &a->ns1__GetLotteryWinningTop, ""))
				{	soap_flag_ns1__GetLotteryWinningTop--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLotteryWinningTop(struct soap *soap, const struct __ns1__GetLotteryWinningTop *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLotteryWinningTop(soap, tag?tag:"-ns1:GetLotteryWinningTop", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotteryWinningTop * SOAP_FMAC4 soap_get___ns1__GetLotteryWinningTop(struct soap *soap, struct __ns1__GetLotteryWinningTop *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLotteryWinningTop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetLotteryWinningTop * SOAP_FMAC2 soap_instantiate___ns1__GetLotteryWinningTop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLotteryWinningTop(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetLotteryWinningTop, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetLotteryWinningTop);
		if (size)
			*size = sizeof(struct __ns1__GetLotteryWinningTop);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetLotteryWinningTop, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetLotteryWinningTop);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetLotteryWinningTop*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetLotteryWinningTop(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetLotteryWinningTop %p -> %p\n", q, p));
	*(struct __ns1__GetLotteryWinningTop*)p = *(struct __ns1__GetLotteryWinningTop*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLotteryPrize(struct soap *soap, struct __ns1__GetLotteryPrize *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLotteryPrize = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLotteryPrize(struct soap *soap, const struct __ns1__GetLotteryPrize *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLotteryPrize(soap, &a->ns1__GetLotteryPrize);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLotteryPrize(struct soap *soap, const char *tag, int id, const struct __ns1__GetLotteryPrize *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetLotteryPrize(soap, "ns1:GetLotteryPrize", -1, &a->ns1__GetLotteryPrize, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotteryPrize * SOAP_FMAC4 soap_in___ns1__GetLotteryPrize(struct soap *soap, const char *tag, struct __ns1__GetLotteryPrize *a, const char *type)
{
	size_t soap_flag_ns1__GetLotteryPrize = 1;
	short soap_flag;
	a = (struct __ns1__GetLotteryPrize *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLotteryPrize, sizeof(struct __ns1__GetLotteryPrize), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLotteryPrize(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLotteryPrize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLotteryPrize(soap, "ns1:GetLotteryPrize", &a->ns1__GetLotteryPrize, ""))
				{	soap_flag_ns1__GetLotteryPrize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLotteryPrize(struct soap *soap, const struct __ns1__GetLotteryPrize *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLotteryPrize(soap, tag?tag:"-ns1:GetLotteryPrize", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLotteryPrize * SOAP_FMAC4 soap_get___ns1__GetLotteryPrize(struct soap *soap, struct __ns1__GetLotteryPrize *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLotteryPrize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetLotteryPrize * SOAP_FMAC2 soap_instantiate___ns1__GetLotteryPrize(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLotteryPrize(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetLotteryPrize, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetLotteryPrize);
		if (size)
			*size = sizeof(struct __ns1__GetLotteryPrize);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetLotteryPrize, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetLotteryPrize);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetLotteryPrize*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetLotteryPrize(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetLotteryPrize %p -> %p\n", q, p));
	*(struct __ns1__GetLotteryPrize*)p = *(struct __ns1__GetLotteryPrize*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Lottery(struct soap *soap, struct __ns1__Lottery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Lottery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Lottery(struct soap *soap, const struct __ns1__Lottery *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Lottery(soap, &a->ns1__Lottery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Lottery(struct soap *soap, const char *tag, int id, const struct __ns1__Lottery *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__Lottery(soap, "ns1:Lottery", -1, &a->ns1__Lottery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Lottery * SOAP_FMAC4 soap_in___ns1__Lottery(struct soap *soap, const char *tag, struct __ns1__Lottery *a, const char *type)
{
	size_t soap_flag_ns1__Lottery = 1;
	short soap_flag;
	a = (struct __ns1__Lottery *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Lottery, sizeof(struct __ns1__Lottery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Lottery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Lottery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Lottery(soap, "ns1:Lottery", &a->ns1__Lottery, ""))
				{	soap_flag_ns1__Lottery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Lottery(struct soap *soap, const struct __ns1__Lottery *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Lottery(soap, tag?tag:"-ns1:Lottery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Lottery * SOAP_FMAC4 soap_get___ns1__Lottery(struct soap *soap, struct __ns1__Lottery *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Lottery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__Lottery * SOAP_FMAC2 soap_instantiate___ns1__Lottery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Lottery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Lottery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__Lottery);
		if (size)
			*size = sizeof(struct __ns1__Lottery);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__Lottery, n);
		if (size)
			*size = n * sizeof(struct __ns1__Lottery);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__Lottery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Lottery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Lottery %p -> %p\n", q, p));
	*(struct __ns1__Lottery*)p = *(struct __ns1__Lottery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAwardInfo(struct soap *soap, struct __ns1__GetAwardInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAwardInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAwardInfo(struct soap *soap, const struct __ns1__GetAwardInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAwardInfo(soap, &a->ns1__GetAwardInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAwardInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetAwardInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAwardInfo(soap, "ns1:GetAwardInfo", -1, &a->ns1__GetAwardInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAwardInfo * SOAP_FMAC4 soap_in___ns1__GetAwardInfo(struct soap *soap, const char *tag, struct __ns1__GetAwardInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetAwardInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetAwardInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAwardInfo, sizeof(struct __ns1__GetAwardInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAwardInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAwardInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAwardInfo(soap, "ns1:GetAwardInfo", &a->ns1__GetAwardInfo, ""))
				{	soap_flag_ns1__GetAwardInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAwardInfo(struct soap *soap, const struct __ns1__GetAwardInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAwardInfo(soap, tag?tag:"-ns1:GetAwardInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAwardInfo * SOAP_FMAC4 soap_get___ns1__GetAwardInfo(struct soap *soap, struct __ns1__GetAwardInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAwardInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAwardInfo * SOAP_FMAC2 soap_instantiate___ns1__GetAwardInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAwardInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAwardInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAwardInfo);
		if (size)
			*size = sizeof(struct __ns1__GetAwardInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAwardInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAwardInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAwardInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAwardInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAwardInfo %p -> %p\n", q, p));
	*(struct __ns1__GetAwardInfo*)p = *(struct __ns1__GetAwardInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAwardItem(struct soap *soap, struct __ns1__GetAwardItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAwardItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAwardItem(struct soap *soap, const struct __ns1__GetAwardItem *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAwardItem(soap, &a->ns1__GetAwardItem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAwardItem(struct soap *soap, const char *tag, int id, const struct __ns1__GetAwardItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAwardItem(soap, "ns1:GetAwardItem", -1, &a->ns1__GetAwardItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAwardItem * SOAP_FMAC4 soap_in___ns1__GetAwardItem(struct soap *soap, const char *tag, struct __ns1__GetAwardItem *a, const char *type)
{
	size_t soap_flag_ns1__GetAwardItem = 1;
	short soap_flag;
	a = (struct __ns1__GetAwardItem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAwardItem, sizeof(struct __ns1__GetAwardItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAwardItem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAwardItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAwardItem(soap, "ns1:GetAwardItem", &a->ns1__GetAwardItem, ""))
				{	soap_flag_ns1__GetAwardItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAwardItem(struct soap *soap, const struct __ns1__GetAwardItem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAwardItem(soap, tag?tag:"-ns1:GetAwardItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAwardItem * SOAP_FMAC4 soap_get___ns1__GetAwardItem(struct soap *soap, struct __ns1__GetAwardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAwardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAwardItem * SOAP_FMAC2 soap_instantiate___ns1__GetAwardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAwardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAwardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAwardItem);
		if (size)
			*size = sizeof(struct __ns1__GetAwardItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAwardItem, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAwardItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAwardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAwardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAwardItem %p -> %p\n", q, p));
	*(struct __ns1__GetAwardItem*)p = *(struct __ns1__GetAwardItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__AwardItem(struct soap *soap, struct __ns1__AwardItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AwardItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__AwardItem(struct soap *soap, const struct __ns1__AwardItem *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__AwardItem(soap, &a->ns1__AwardItem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__AwardItem(struct soap *soap, const char *tag, int id, const struct __ns1__AwardItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__AwardItem(soap, "ns1:AwardItem", -1, &a->ns1__AwardItem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AwardItem * SOAP_FMAC4 soap_in___ns1__AwardItem(struct soap *soap, const char *tag, struct __ns1__AwardItem *a, const char *type)
{
	size_t soap_flag_ns1__AwardItem = 1;
	short soap_flag;
	a = (struct __ns1__AwardItem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__AwardItem, sizeof(struct __ns1__AwardItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__AwardItem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AwardItem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AwardItem(soap, "ns1:AwardItem", &a->ns1__AwardItem, ""))
				{	soap_flag_ns1__AwardItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__AwardItem(struct soap *soap, const struct __ns1__AwardItem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__AwardItem(soap, tag?tag:"-ns1:AwardItem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__AwardItem * SOAP_FMAC4 soap_get___ns1__AwardItem(struct soap *soap, struct __ns1__AwardItem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__AwardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__AwardItem * SOAP_FMAC2 soap_instantiate___ns1__AwardItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__AwardItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__AwardItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__AwardItem);
		if (size)
			*size = sizeof(struct __ns1__AwardItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__AwardItem, n);
		if (size)
			*size = n * sizeof(struct __ns1__AwardItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__AwardItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__AwardItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__AwardItem %p -> %p\n", q, p));
	*(struct __ns1__AwardItem*)p = *(struct __ns1__AwardItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetClothingID(struct soap *soap, struct __ns1__GetClothingID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetClothingID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetClothingID(struct soap *soap, const struct __ns1__GetClothingID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetClothingID(soap, &a->ns1__GetClothingID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetClothingID(struct soap *soap, const char *tag, int id, const struct __ns1__GetClothingID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetClothingID(soap, "ns1:GetClothingID", -1, &a->ns1__GetClothingID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetClothingID * SOAP_FMAC4 soap_in___ns1__GetClothingID(struct soap *soap, const char *tag, struct __ns1__GetClothingID *a, const char *type)
{
	size_t soap_flag_ns1__GetClothingID = 1;
	short soap_flag;
	a = (struct __ns1__GetClothingID *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetClothingID, sizeof(struct __ns1__GetClothingID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetClothingID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetClothingID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetClothingID(soap, "ns1:GetClothingID", &a->ns1__GetClothingID, ""))
				{	soap_flag_ns1__GetClothingID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetClothingID(struct soap *soap, const struct __ns1__GetClothingID *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetClothingID(soap, tag?tag:"-ns1:GetClothingID", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetClothingID * SOAP_FMAC4 soap_get___ns1__GetClothingID(struct soap *soap, struct __ns1__GetClothingID *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetClothingID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetClothingID * SOAP_FMAC2 soap_instantiate___ns1__GetClothingID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetClothingID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetClothingID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetClothingID);
		if (size)
			*size = sizeof(struct __ns1__GetClothingID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetClothingID, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetClothingID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetClothingID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetClothingID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetClothingID %p -> %p\n", q, p));
	*(struct __ns1__GetClothingID*)p = *(struct __ns1__GetClothingID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetItemValue(struct soap *soap, struct __ns1__GetItemValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetItemValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetItemValue(struct soap *soap, const struct __ns1__GetItemValue *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetItemValue(soap, &a->ns1__GetItemValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetItemValue(struct soap *soap, const char *tag, int id, const struct __ns1__GetItemValue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetItemValue(soap, "ns1:GetItemValue", -1, &a->ns1__GetItemValue, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetItemValue * SOAP_FMAC4 soap_in___ns1__GetItemValue(struct soap *soap, const char *tag, struct __ns1__GetItemValue *a, const char *type)
{
	size_t soap_flag_ns1__GetItemValue = 1;
	short soap_flag;
	a = (struct __ns1__GetItemValue *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetItemValue, sizeof(struct __ns1__GetItemValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetItemValue(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetItemValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetItemValue(soap, "ns1:GetItemValue", &a->ns1__GetItemValue, ""))
				{	soap_flag_ns1__GetItemValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetItemValue(struct soap *soap, const struct __ns1__GetItemValue *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetItemValue(soap, tag?tag:"-ns1:GetItemValue", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetItemValue * SOAP_FMAC4 soap_get___ns1__GetItemValue(struct soap *soap, struct __ns1__GetItemValue *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetItemValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetItemValue * SOAP_FMAC2 soap_instantiate___ns1__GetItemValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetItemValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetItemValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetItemValue);
		if (size)
			*size = sizeof(struct __ns1__GetItemValue);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetItemValue, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetItemValue);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetItemValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetItemValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetItemValue %p -> %p\n", q, p));
	*(struct __ns1__GetItemValue*)p = *(struct __ns1__GetItemValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetItemByItemID(struct soap *soap, struct __ns1__GetItemByItemID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetItemByItemID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetItemByItemID(struct soap *soap, const struct __ns1__GetItemByItemID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetItemByItemID(soap, &a->ns1__GetItemByItemID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetItemByItemID(struct soap *soap, const char *tag, int id, const struct __ns1__GetItemByItemID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetItemByItemID(soap, "ns1:GetItemByItemID", -1, &a->ns1__GetItemByItemID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetItemByItemID * SOAP_FMAC4 soap_in___ns1__GetItemByItemID(struct soap *soap, const char *tag, struct __ns1__GetItemByItemID *a, const char *type)
{
	size_t soap_flag_ns1__GetItemByItemID = 1;
	short soap_flag;
	a = (struct __ns1__GetItemByItemID *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetItemByItemID, sizeof(struct __ns1__GetItemByItemID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetItemByItemID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetItemByItemID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetItemByItemID(soap, "ns1:GetItemByItemID", &a->ns1__GetItemByItemID, ""))
				{	soap_flag_ns1__GetItemByItemID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetItemByItemID(struct soap *soap, const struct __ns1__GetItemByItemID *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetItemByItemID(soap, tag?tag:"-ns1:GetItemByItemID", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetItemByItemID * SOAP_FMAC4 soap_get___ns1__GetItemByItemID(struct soap *soap, struct __ns1__GetItemByItemID *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetItemByItemID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetItemByItemID * SOAP_FMAC2 soap_instantiate___ns1__GetItemByItemID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetItemByItemID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetItemByItemID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetItemByItemID);
		if (size)
			*size = sizeof(struct __ns1__GetItemByItemID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetItemByItemID, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetItemByItemID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetItemByItemID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetItemByItemID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetItemByItemID %p -> %p\n", q, p));
	*(struct __ns1__GetItemByItemID*)p = *(struct __ns1__GetItemByItemID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetItemByCode(struct soap *soap, struct __ns1__GetItemByCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetItemByCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetItemByCode(struct soap *soap, const struct __ns1__GetItemByCode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetItemByCode(soap, &a->ns1__GetItemByCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetItemByCode(struct soap *soap, const char *tag, int id, const struct __ns1__GetItemByCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetItemByCode(soap, "ns1:GetItemByCode", -1, &a->ns1__GetItemByCode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetItemByCode * SOAP_FMAC4 soap_in___ns1__GetItemByCode(struct soap *soap, const char *tag, struct __ns1__GetItemByCode *a, const char *type)
{
	size_t soap_flag_ns1__GetItemByCode = 1;
	short soap_flag;
	a = (struct __ns1__GetItemByCode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetItemByCode, sizeof(struct __ns1__GetItemByCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetItemByCode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetItemByCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetItemByCode(soap, "ns1:GetItemByCode", &a->ns1__GetItemByCode, ""))
				{	soap_flag_ns1__GetItemByCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetItemByCode(struct soap *soap, const struct __ns1__GetItemByCode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetItemByCode(soap, tag?tag:"-ns1:GetItemByCode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetItemByCode * SOAP_FMAC4 soap_get___ns1__GetItemByCode(struct soap *soap, struct __ns1__GetItemByCode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetItemByCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetItemByCode * SOAP_FMAC2 soap_instantiate___ns1__GetItemByCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetItemByCode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetItemByCode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetItemByCode);
		if (size)
			*size = sizeof(struct __ns1__GetItemByCode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetItemByCode, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetItemByCode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetItemByCode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetItemByCode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetItemByCode %p -> %p\n", q, p));
	*(struct __ns1__GetItemByCode*)p = *(struct __ns1__GetItemByCode*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLotteryWinningListResponse(struct soap *soap, _ns1__GetLotteryWinningListResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLotteryWinningListResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLotteryWinningListResponse(struct soap *soap, const char *tag, int id, _ns1__GetLotteryWinningListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLotteryWinningListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLotteryWinningListResponse(struct soap *soap, const char *tag, _ns1__GetLotteryWinningListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLotteryWinningListResponse **)soap_malloc(soap, sizeof(_ns1__GetLotteryWinningListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLotteryWinningListResponse *)soap_instantiate__ns1__GetLotteryWinningListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLotteryWinningListResponse ** p = (_ns1__GetLotteryWinningListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLotteryWinningListResponse, sizeof(_ns1__GetLotteryWinningListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLotteryWinningListResponse(struct soap *soap, _ns1__GetLotteryWinningListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLotteryWinningListResponse);
	if (soap_out_PointerTo_ns1__GetLotteryWinningListResponse(soap, tag?tag:"ns1:GetLotteryWinningListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLotteryWinningListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLotteryWinningListResponse(struct soap *soap, _ns1__GetLotteryWinningListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLotteryWinningListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLotteryWinningList(struct soap *soap, _ns1__GetLotteryWinningList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLotteryWinningList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLotteryWinningList(struct soap *soap, const char *tag, int id, _ns1__GetLotteryWinningList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLotteryWinningList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningList ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLotteryWinningList(struct soap *soap, const char *tag, _ns1__GetLotteryWinningList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLotteryWinningList **)soap_malloc(soap, sizeof(_ns1__GetLotteryWinningList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLotteryWinningList *)soap_instantiate__ns1__GetLotteryWinningList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLotteryWinningList ** p = (_ns1__GetLotteryWinningList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLotteryWinningList, sizeof(_ns1__GetLotteryWinningList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLotteryWinningList(struct soap *soap, _ns1__GetLotteryWinningList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLotteryWinningList);
	if (soap_out_PointerTo_ns1__GetLotteryWinningList(soap, tag?tag:"ns1:GetLotteryWinningList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLotteryWinningList ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLotteryWinningList(struct soap *soap, _ns1__GetLotteryWinningList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLotteryWinningList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLotteryWinningTopResponse(struct soap *soap, _ns1__GetLotteryWinningTopResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLotteryWinningTopResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLotteryWinningTopResponse(struct soap *soap, const char *tag, int id, _ns1__GetLotteryWinningTopResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLotteryWinningTopResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningTopResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLotteryWinningTopResponse(struct soap *soap, const char *tag, _ns1__GetLotteryWinningTopResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLotteryWinningTopResponse **)soap_malloc(soap, sizeof(_ns1__GetLotteryWinningTopResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLotteryWinningTopResponse *)soap_instantiate__ns1__GetLotteryWinningTopResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLotteryWinningTopResponse ** p = (_ns1__GetLotteryWinningTopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLotteryWinningTopResponse, sizeof(_ns1__GetLotteryWinningTopResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLotteryWinningTopResponse(struct soap *soap, _ns1__GetLotteryWinningTopResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLotteryWinningTopResponse);
	if (soap_out_PointerTo_ns1__GetLotteryWinningTopResponse(soap, tag?tag:"ns1:GetLotteryWinningTopResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLotteryWinningTopResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLotteryWinningTopResponse(struct soap *soap, _ns1__GetLotteryWinningTopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLotteryWinningTopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLotteryWinningTop(struct soap *soap, _ns1__GetLotteryWinningTop *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLotteryWinningTop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLotteryWinningTop(struct soap *soap, const char *tag, int id, _ns1__GetLotteryWinningTop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLotteryWinningTop);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningTop ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLotteryWinningTop(struct soap *soap, const char *tag, _ns1__GetLotteryWinningTop **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLotteryWinningTop **)soap_malloc(soap, sizeof(_ns1__GetLotteryWinningTop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLotteryWinningTop *)soap_instantiate__ns1__GetLotteryWinningTop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLotteryWinningTop ** p = (_ns1__GetLotteryWinningTop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLotteryWinningTop, sizeof(_ns1__GetLotteryWinningTop), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLotteryWinningTop(struct soap *soap, _ns1__GetLotteryWinningTop *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLotteryWinningTop);
	if (soap_out_PointerTo_ns1__GetLotteryWinningTop(soap, tag?tag:"ns1:GetLotteryWinningTop", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLotteryWinningTop ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLotteryWinningTop(struct soap *soap, _ns1__GetLotteryWinningTop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLotteryWinningTop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLotteryPrizeResponse(struct soap *soap, _ns1__GetLotteryPrizeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLotteryPrizeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLotteryPrizeResponse(struct soap *soap, const char *tag, int id, _ns1__GetLotteryPrizeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLotteryPrizeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLotteryPrizeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLotteryPrizeResponse(struct soap *soap, const char *tag, _ns1__GetLotteryPrizeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLotteryPrizeResponse **)soap_malloc(soap, sizeof(_ns1__GetLotteryPrizeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLotteryPrizeResponse *)soap_instantiate__ns1__GetLotteryPrizeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLotteryPrizeResponse ** p = (_ns1__GetLotteryPrizeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLotteryPrizeResponse, sizeof(_ns1__GetLotteryPrizeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLotteryPrizeResponse(struct soap *soap, _ns1__GetLotteryPrizeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLotteryPrizeResponse);
	if (soap_out_PointerTo_ns1__GetLotteryPrizeResponse(soap, tag?tag:"ns1:GetLotteryPrizeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLotteryPrizeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLotteryPrizeResponse(struct soap *soap, _ns1__GetLotteryPrizeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLotteryPrizeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLotteryPrize(struct soap *soap, _ns1__GetLotteryPrize *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLotteryPrize))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLotteryPrize(struct soap *soap, const char *tag, int id, _ns1__GetLotteryPrize *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLotteryPrize);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLotteryPrize ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLotteryPrize(struct soap *soap, const char *tag, _ns1__GetLotteryPrize **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLotteryPrize **)soap_malloc(soap, sizeof(_ns1__GetLotteryPrize *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLotteryPrize *)soap_instantiate__ns1__GetLotteryPrize(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLotteryPrize ** p = (_ns1__GetLotteryPrize **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLotteryPrize, sizeof(_ns1__GetLotteryPrize), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLotteryPrize(struct soap *soap, _ns1__GetLotteryPrize *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLotteryPrize);
	if (soap_out_PointerTo_ns1__GetLotteryPrize(soap, tag?tag:"ns1:GetLotteryPrize", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLotteryPrize ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLotteryPrize(struct soap *soap, _ns1__GetLotteryPrize **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLotteryPrize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LotteryResponse(struct soap *soap, _ns1__LotteryResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LotteryResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LotteryResponse(struct soap *soap, const char *tag, int id, _ns1__LotteryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LotteryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LotteryResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__LotteryResponse(struct soap *soap, const char *tag, _ns1__LotteryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LotteryResponse **)soap_malloc(soap, sizeof(_ns1__LotteryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LotteryResponse *)soap_instantiate__ns1__LotteryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__LotteryResponse ** p = (_ns1__LotteryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LotteryResponse, sizeof(_ns1__LotteryResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LotteryResponse(struct soap *soap, _ns1__LotteryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__LotteryResponse);
	if (soap_out_PointerTo_ns1__LotteryResponse(soap, tag?tag:"ns1:LotteryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LotteryResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__LotteryResponse(struct soap *soap, _ns1__LotteryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LotteryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Lottery(struct soap *soap, _ns1__Lottery *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Lottery))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Lottery(struct soap *soap, const char *tag, int id, _ns1__Lottery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Lottery);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Lottery ** SOAP_FMAC4 soap_in_PointerTo_ns1__Lottery(struct soap *soap, const char *tag, _ns1__Lottery **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Lottery **)soap_malloc(soap, sizeof(_ns1__Lottery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Lottery *)soap_instantiate__ns1__Lottery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__Lottery ** p = (_ns1__Lottery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Lottery, sizeof(_ns1__Lottery), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Lottery(struct soap *soap, _ns1__Lottery *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Lottery);
	if (soap_out_PointerTo_ns1__Lottery(soap, tag?tag:"ns1:Lottery", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Lottery ** SOAP_FMAC4 soap_get_PointerTo_ns1__Lottery(struct soap *soap, _ns1__Lottery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Lottery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAwardInfoResponse(struct soap *soap, _ns1__GetAwardInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAwardInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAwardInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetAwardInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAwardInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAwardInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAwardInfoResponse(struct soap *soap, const char *tag, _ns1__GetAwardInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAwardInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetAwardInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAwardInfoResponse *)soap_instantiate__ns1__GetAwardInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAwardInfoResponse ** p = (_ns1__GetAwardInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAwardInfoResponse, sizeof(_ns1__GetAwardInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAwardInfoResponse(struct soap *soap, _ns1__GetAwardInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAwardInfoResponse);
	if (soap_out_PointerTo_ns1__GetAwardInfoResponse(soap, tag?tag:"ns1:GetAwardInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAwardInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAwardInfoResponse(struct soap *soap, _ns1__GetAwardInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAwardInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAwardInfo(struct soap *soap, _ns1__GetAwardInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAwardInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAwardInfo(struct soap *soap, const char *tag, int id, _ns1__GetAwardInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAwardInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAwardInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAwardInfo(struct soap *soap, const char *tag, _ns1__GetAwardInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAwardInfo **)soap_malloc(soap, sizeof(_ns1__GetAwardInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAwardInfo *)soap_instantiate__ns1__GetAwardInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAwardInfo ** p = (_ns1__GetAwardInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAwardInfo, sizeof(_ns1__GetAwardInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAwardInfo(struct soap *soap, _ns1__GetAwardInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAwardInfo);
	if (soap_out_PointerTo_ns1__GetAwardInfo(soap, tag?tag:"ns1:GetAwardInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAwardInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAwardInfo(struct soap *soap, _ns1__GetAwardInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAwardInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAwardItemResponse(struct soap *soap, _ns1__GetAwardItemResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAwardItemResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAwardItemResponse(struct soap *soap, const char *tag, int id, _ns1__GetAwardItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAwardItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAwardItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAwardItemResponse(struct soap *soap, const char *tag, _ns1__GetAwardItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAwardItemResponse **)soap_malloc(soap, sizeof(_ns1__GetAwardItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAwardItemResponse *)soap_instantiate__ns1__GetAwardItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAwardItemResponse ** p = (_ns1__GetAwardItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAwardItemResponse, sizeof(_ns1__GetAwardItemResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAwardItemResponse(struct soap *soap, _ns1__GetAwardItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAwardItemResponse);
	if (soap_out_PointerTo_ns1__GetAwardItemResponse(soap, tag?tag:"ns1:GetAwardItemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAwardItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAwardItemResponse(struct soap *soap, _ns1__GetAwardItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAwardItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAwardItem(struct soap *soap, _ns1__GetAwardItem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAwardItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAwardItem(struct soap *soap, const char *tag, int id, _ns1__GetAwardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAwardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAwardItem ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAwardItem(struct soap *soap, const char *tag, _ns1__GetAwardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAwardItem **)soap_malloc(soap, sizeof(_ns1__GetAwardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAwardItem *)soap_instantiate__ns1__GetAwardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAwardItem ** p = (_ns1__GetAwardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAwardItem, sizeof(_ns1__GetAwardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAwardItem(struct soap *soap, _ns1__GetAwardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAwardItem);
	if (soap_out_PointerTo_ns1__GetAwardItem(soap, tag?tag:"ns1:GetAwardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAwardItem ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAwardItem(struct soap *soap, _ns1__GetAwardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAwardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AwardItemResponse(struct soap *soap, _ns1__AwardItemResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AwardItemResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AwardItemResponse(struct soap *soap, const char *tag, int id, _ns1__AwardItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AwardItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AwardItemResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__AwardItemResponse(struct soap *soap, const char *tag, _ns1__AwardItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AwardItemResponse **)soap_malloc(soap, sizeof(_ns1__AwardItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AwardItemResponse *)soap_instantiate__ns1__AwardItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AwardItemResponse ** p = (_ns1__AwardItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AwardItemResponse, sizeof(_ns1__AwardItemResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AwardItemResponse(struct soap *soap, _ns1__AwardItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AwardItemResponse);
	if (soap_out_PointerTo_ns1__AwardItemResponse(soap, tag?tag:"ns1:AwardItemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AwardItemResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__AwardItemResponse(struct soap *soap, _ns1__AwardItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AwardItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AwardItem(struct soap *soap, _ns1__AwardItem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AwardItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AwardItem(struct soap *soap, const char *tag, int id, _ns1__AwardItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AwardItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AwardItem ** SOAP_FMAC4 soap_in_PointerTo_ns1__AwardItem(struct soap *soap, const char *tag, _ns1__AwardItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AwardItem **)soap_malloc(soap, sizeof(_ns1__AwardItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AwardItem *)soap_instantiate__ns1__AwardItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__AwardItem ** p = (_ns1__AwardItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AwardItem, sizeof(_ns1__AwardItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AwardItem(struct soap *soap, _ns1__AwardItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__AwardItem);
	if (soap_out_PointerTo_ns1__AwardItem(soap, tag?tag:"ns1:AwardItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AwardItem ** SOAP_FMAC4 soap_get_PointerTo_ns1__AwardItem(struct soap *soap, _ns1__AwardItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AwardItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetClothingIDResponse(struct soap *soap, _ns1__GetClothingIDResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetClothingIDResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetClothingIDResponse(struct soap *soap, const char *tag, int id, _ns1__GetClothingIDResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetClothingIDResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetClothingIDResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetClothingIDResponse(struct soap *soap, const char *tag, _ns1__GetClothingIDResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetClothingIDResponse **)soap_malloc(soap, sizeof(_ns1__GetClothingIDResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetClothingIDResponse *)soap_instantiate__ns1__GetClothingIDResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetClothingIDResponse ** p = (_ns1__GetClothingIDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetClothingIDResponse, sizeof(_ns1__GetClothingIDResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetClothingIDResponse(struct soap *soap, _ns1__GetClothingIDResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetClothingIDResponse);
	if (soap_out_PointerTo_ns1__GetClothingIDResponse(soap, tag?tag:"ns1:GetClothingIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetClothingIDResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetClothingIDResponse(struct soap *soap, _ns1__GetClothingIDResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetClothingIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetClothingID(struct soap *soap, _ns1__GetClothingID *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetClothingID))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetClothingID(struct soap *soap, const char *tag, int id, _ns1__GetClothingID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetClothingID);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetClothingID ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetClothingID(struct soap *soap, const char *tag, _ns1__GetClothingID **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetClothingID **)soap_malloc(soap, sizeof(_ns1__GetClothingID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetClothingID *)soap_instantiate__ns1__GetClothingID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetClothingID ** p = (_ns1__GetClothingID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetClothingID, sizeof(_ns1__GetClothingID), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetClothingID(struct soap *soap, _ns1__GetClothingID *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetClothingID);
	if (soap_out_PointerTo_ns1__GetClothingID(soap, tag?tag:"ns1:GetClothingID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetClothingID ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetClothingID(struct soap *soap, _ns1__GetClothingID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetClothingID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetItemValueResponse(struct soap *soap, _ns1__GetItemValueResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetItemValueResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetItemValueResponse(struct soap *soap, const char *tag, int id, _ns1__GetItemValueResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetItemValueResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetItemValueResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetItemValueResponse(struct soap *soap, const char *tag, _ns1__GetItemValueResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetItemValueResponse **)soap_malloc(soap, sizeof(_ns1__GetItemValueResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetItemValueResponse *)soap_instantiate__ns1__GetItemValueResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetItemValueResponse ** p = (_ns1__GetItemValueResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetItemValueResponse, sizeof(_ns1__GetItemValueResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetItemValueResponse(struct soap *soap, _ns1__GetItemValueResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetItemValueResponse);
	if (soap_out_PointerTo_ns1__GetItemValueResponse(soap, tag?tag:"ns1:GetItemValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetItemValueResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetItemValueResponse(struct soap *soap, _ns1__GetItemValueResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetItemValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetItemValue(struct soap *soap, _ns1__GetItemValue *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetItemValue))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetItemValue(struct soap *soap, const char *tag, int id, _ns1__GetItemValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetItemValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetItemValue ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetItemValue(struct soap *soap, const char *tag, _ns1__GetItemValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetItemValue **)soap_malloc(soap, sizeof(_ns1__GetItemValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetItemValue *)soap_instantiate__ns1__GetItemValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetItemValue ** p = (_ns1__GetItemValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetItemValue, sizeof(_ns1__GetItemValue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetItemValue(struct soap *soap, _ns1__GetItemValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetItemValue);
	if (soap_out_PointerTo_ns1__GetItemValue(soap, tag?tag:"ns1:GetItemValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetItemValue ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetItemValue(struct soap *soap, _ns1__GetItemValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetItemValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetItemByItemIDResponse(struct soap *soap, _ns1__GetItemByItemIDResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetItemByItemIDResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetItemByItemIDResponse(struct soap *soap, const char *tag, int id, _ns1__GetItemByItemIDResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetItemByItemIDResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetItemByItemIDResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetItemByItemIDResponse(struct soap *soap, const char *tag, _ns1__GetItemByItemIDResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetItemByItemIDResponse **)soap_malloc(soap, sizeof(_ns1__GetItemByItemIDResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetItemByItemIDResponse *)soap_instantiate__ns1__GetItemByItemIDResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetItemByItemIDResponse ** p = (_ns1__GetItemByItemIDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetItemByItemIDResponse, sizeof(_ns1__GetItemByItemIDResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetItemByItemIDResponse(struct soap *soap, _ns1__GetItemByItemIDResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetItemByItemIDResponse);
	if (soap_out_PointerTo_ns1__GetItemByItemIDResponse(soap, tag?tag:"ns1:GetItemByItemIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetItemByItemIDResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetItemByItemIDResponse(struct soap *soap, _ns1__GetItemByItemIDResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetItemByItemIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetItemByItemID(struct soap *soap, _ns1__GetItemByItemID *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetItemByItemID))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetItemByItemID(struct soap *soap, const char *tag, int id, _ns1__GetItemByItemID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetItemByItemID);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetItemByItemID ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetItemByItemID(struct soap *soap, const char *tag, _ns1__GetItemByItemID **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetItemByItemID **)soap_malloc(soap, sizeof(_ns1__GetItemByItemID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetItemByItemID *)soap_instantiate__ns1__GetItemByItemID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetItemByItemID ** p = (_ns1__GetItemByItemID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetItemByItemID, sizeof(_ns1__GetItemByItemID), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetItemByItemID(struct soap *soap, _ns1__GetItemByItemID *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetItemByItemID);
	if (soap_out_PointerTo_ns1__GetItemByItemID(soap, tag?tag:"ns1:GetItemByItemID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetItemByItemID ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetItemByItemID(struct soap *soap, _ns1__GetItemByItemID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetItemByItemID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetItemByCodeResponse(struct soap *soap, _ns1__GetItemByCodeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetItemByCodeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetItemByCodeResponse(struct soap *soap, const char *tag, int id, _ns1__GetItemByCodeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetItemByCodeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetItemByCodeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetItemByCodeResponse(struct soap *soap, const char *tag, _ns1__GetItemByCodeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetItemByCodeResponse **)soap_malloc(soap, sizeof(_ns1__GetItemByCodeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetItemByCodeResponse *)soap_instantiate__ns1__GetItemByCodeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetItemByCodeResponse ** p = (_ns1__GetItemByCodeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetItemByCodeResponse, sizeof(_ns1__GetItemByCodeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetItemByCodeResponse(struct soap *soap, _ns1__GetItemByCodeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetItemByCodeResponse);
	if (soap_out_PointerTo_ns1__GetItemByCodeResponse(soap, tag?tag:"ns1:GetItemByCodeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetItemByCodeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetItemByCodeResponse(struct soap *soap, _ns1__GetItemByCodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetItemByCodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetItemByCode(struct soap *soap, _ns1__GetItemByCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetItemByCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetItemByCode(struct soap *soap, const char *tag, int id, _ns1__GetItemByCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetItemByCode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetItemByCode ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetItemByCode(struct soap *soap, const char *tag, _ns1__GetItemByCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetItemByCode **)soap_malloc(soap, sizeof(_ns1__GetItemByCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetItemByCode *)soap_instantiate__ns1__GetItemByCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetItemByCode ** p = (_ns1__GetItemByCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetItemByCode, sizeof(_ns1__GetItemByCode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetItemByCode(struct soap *soap, _ns1__GetItemByCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetItemByCode);
	if (soap_out_PointerTo_ns1__GetItemByCode(soap, tag?tag:"ns1:GetItemByCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetItemByCode ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetItemByCode(struct soap *soap, _ns1__GetItemByCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetItemByCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(struct soap *soap, _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(struct soap *soap, const char *tag, int id, _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(struct soap *soap, const char *tag, _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult **)soap_malloc(soap, sizeof(_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *)soap_instantiate__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult ** p = (_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult, sizeof(_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(struct soap *soap, _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult);
	if (soap_out_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, tag?tag:"ns1:GetLotteryWinningListResponse-GetLotteryWinningListResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(struct soap *soap, _ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLotteryWinningListResponse_GetLotteryWinningListResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(struct soap *soap, _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(struct soap *soap, const char *tag, int id, _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(struct soap *soap, const char *tag, _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult **)soap_malloc(soap, sizeof(_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *)soap_instantiate__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult ** p = (_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult, sizeof(_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(struct soap *soap, _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult);
	if (soap_out_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, tag?tag:"ns1:GetLotteryWinningTopResponse-GetLotteryWinningTopResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(struct soap *soap, _ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLotteryWinningTopResponse_GetLotteryWinningTopResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfAwardLotteryPrizeInfo(struct soap *soap, ns1__ArrayOfAwardLotteryPrizeInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfAwardLotteryPrizeInfo(struct soap *soap, const char *tag, int id, ns1__ArrayOfAwardLotteryPrizeInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfAwardLotteryPrizeInfo ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfAwardLotteryPrizeInfo(struct soap *soap, const char *tag, ns1__ArrayOfAwardLotteryPrizeInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfAwardLotteryPrizeInfo **)soap_malloc(soap, sizeof(ns1__ArrayOfAwardLotteryPrizeInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfAwardLotteryPrizeInfo *)soap_instantiate_ns1__ArrayOfAwardLotteryPrizeInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfAwardLotteryPrizeInfo ** p = (ns1__ArrayOfAwardLotteryPrizeInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfAwardLotteryPrizeInfo, sizeof(ns1__ArrayOfAwardLotteryPrizeInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfAwardLotteryPrizeInfo(struct soap *soap, ns1__ArrayOfAwardLotteryPrizeInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfAwardLotteryPrizeInfo);
	if (soap_out_PointerTons1__ArrayOfAwardLotteryPrizeInfo(soap, tag?tag:"ns1:ArrayOfAwardLotteryPrizeInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfAwardLotteryPrizeInfo ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfAwardLotteryPrizeInfo(struct soap *soap, ns1__ArrayOfAwardLotteryPrizeInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfAwardLotteryPrizeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AwardInfo(struct soap *soap, ns1__AwardInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AwardInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AwardInfo(struct soap *soap, const char *tag, int id, ns1__AwardInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AwardInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AwardInfo ** SOAP_FMAC4 soap_in_PointerTons1__AwardInfo(struct soap *soap, const char *tag, ns1__AwardInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AwardInfo **)soap_malloc(soap, sizeof(ns1__AwardInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AwardInfo *)soap_instantiate_ns1__AwardInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AwardInfo ** p = (ns1__AwardInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AwardInfo, sizeof(ns1__AwardInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AwardInfo(struct soap *soap, ns1__AwardInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AwardInfo);
	if (soap_out_PointerTons1__AwardInfo(soap, tag?tag:"ns1:AwardInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AwardInfo ** SOAP_FMAC4 soap_get_PointerTons1__AwardInfo(struct soap *soap, ns1__AwardInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AwardInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfAwardItemInfo(struct soap *soap, ns1__ArrayOfAwardItemInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfAwardItemInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfAwardItemInfo(struct soap *soap, const char *tag, int id, ns1__ArrayOfAwardItemInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfAwardItemInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ArrayOfAwardItemInfo ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfAwardItemInfo(struct soap *soap, const char *tag, ns1__ArrayOfAwardItemInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfAwardItemInfo **)soap_malloc(soap, sizeof(ns1__ArrayOfAwardItemInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfAwardItemInfo *)soap_instantiate_ns1__ArrayOfAwardItemInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ArrayOfAwardItemInfo ** p = (ns1__ArrayOfAwardItemInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfAwardItemInfo, sizeof(ns1__ArrayOfAwardItemInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfAwardItemInfo(struct soap *soap, ns1__ArrayOfAwardItemInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfAwardItemInfo);
	if (soap_out_PointerTons1__ArrayOfAwardItemInfo(soap, tag?tag:"ns1:ArrayOfAwardItemInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfAwardItemInfo ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfAwardItemInfo(struct soap *soap, ns1__ArrayOfAwardItemInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfAwardItemInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemInfo(struct soap *soap, ns1__ItemInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ItemInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemInfo(struct soap *soap, const char *tag, int id, ns1__ItemInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ItemInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ItemInfo ** SOAP_FMAC4 soap_in_PointerTons1__ItemInfo(struct soap *soap, const char *tag, ns1__ItemInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ItemInfo **)soap_malloc(soap, sizeof(ns1__ItemInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ItemInfo *)soap_instantiate_ns1__ItemInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ItemInfo ** p = (ns1__ItemInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ItemInfo, sizeof(ns1__ItemInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemInfo(struct soap *soap, ns1__ItemInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ItemInfo);
	if (soap_out_PointerTons1__ItemInfo(soap, tag?tag:"ns1:ItemInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ItemInfo ** SOAP_FMAC4 soap_get_PointerTons1__ItemInfo(struct soap *soap, ns1__ItemInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AwardLotteryPrizeInfo(struct soap *soap, ns1__AwardLotteryPrizeInfo **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AwardLotteryPrizeInfo))
		soap_serialize_PointerTons1__AwardLotteryPrizeInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AwardLotteryPrizeInfo(struct soap *soap, const char *tag, int id, ns1__AwardLotteryPrizeInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AwardLotteryPrizeInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AwardLotteryPrizeInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__AwardLotteryPrizeInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AwardLotteryPrizeInfo(struct soap *soap, const char *tag, ns1__AwardLotteryPrizeInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AwardLotteryPrizeInfo ***)soap_malloc(soap, sizeof(ns1__AwardLotteryPrizeInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AwardLotteryPrizeInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__AwardLotteryPrizeInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AwardLotteryPrizeInfo, sizeof(ns1__AwardLotteryPrizeInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AwardLotteryPrizeInfo(struct soap *soap, ns1__AwardLotteryPrizeInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AwardLotteryPrizeInfo);
	if (soap_out_PointerToPointerTons1__AwardLotteryPrizeInfo(soap, tag?tag:"ns1:AwardLotteryPrizeInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AwardLotteryPrizeInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AwardLotteryPrizeInfo(struct soap *soap, ns1__AwardLotteryPrizeInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AwardLotteryPrizeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AwardLotteryPrizeInfo(struct soap *soap, ns1__AwardLotteryPrizeInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AwardLotteryPrizeInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AwardLotteryPrizeInfo(struct soap *soap, const char *tag, int id, ns1__AwardLotteryPrizeInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AwardLotteryPrizeInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AwardLotteryPrizeInfo ** SOAP_FMAC4 soap_in_PointerTons1__AwardLotteryPrizeInfo(struct soap *soap, const char *tag, ns1__AwardLotteryPrizeInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AwardLotteryPrizeInfo **)soap_malloc(soap, sizeof(ns1__AwardLotteryPrizeInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AwardLotteryPrizeInfo *)soap_instantiate_ns1__AwardLotteryPrizeInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AwardLotteryPrizeInfo ** p = (ns1__AwardLotteryPrizeInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AwardLotteryPrizeInfo, sizeof(ns1__AwardLotteryPrizeInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AwardLotteryPrizeInfo(struct soap *soap, ns1__AwardLotteryPrizeInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AwardLotteryPrizeInfo);
	if (soap_out_PointerTons1__AwardLotteryPrizeInfo(soap, tag?tag:"ns1:AwardLotteryPrizeInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AwardLotteryPrizeInfo ** SOAP_FMAC4 soap_get_PointerTons1__AwardLotteryPrizeInfo(struct soap *soap, ns1__AwardLotteryPrizeInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AwardLotteryPrizeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AwardItemInfo(struct soap *soap, ns1__AwardItemInfo **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AwardItemInfo))
		soap_serialize_PointerTons1__AwardItemInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AwardItemInfo(struct soap *soap, const char *tag, int id, ns1__AwardItemInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AwardItemInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AwardItemInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__AwardItemInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AwardItemInfo(struct soap *soap, const char *tag, ns1__AwardItemInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AwardItemInfo ***)soap_malloc(soap, sizeof(ns1__AwardItemInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AwardItemInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__AwardItemInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AwardItemInfo, sizeof(ns1__AwardItemInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AwardItemInfo(struct soap *soap, ns1__AwardItemInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AwardItemInfo);
	if (soap_out_PointerToPointerTons1__AwardItemInfo(soap, tag?tag:"ns1:AwardItemInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AwardItemInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AwardItemInfo(struct soap *soap, ns1__AwardItemInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AwardItemInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AwardItemInfo(struct soap *soap, ns1__AwardItemInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AwardItemInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AwardItemInfo(struct soap *soap, const char *tag, int id, ns1__AwardItemInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AwardItemInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AwardItemInfo ** SOAP_FMAC4 soap_in_PointerTons1__AwardItemInfo(struct soap *soap, const char *tag, ns1__AwardItemInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AwardItemInfo **)soap_malloc(soap, sizeof(ns1__AwardItemInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AwardItemInfo *)soap_instantiate_ns1__AwardItemInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AwardItemInfo ** p = (ns1__AwardItemInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AwardItemInfo, sizeof(ns1__AwardItemInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AwardItemInfo(struct soap *soap, ns1__AwardItemInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AwardItemInfo);
	if (soap_out_PointerTons1__AwardItemInfo(soap, tag?tag:"ns1:AwardItemInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AwardItemInfo ** SOAP_FMAC4 soap_get_PointerTons1__AwardItemInfo(struct soap *soap, ns1__AwardItemInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AwardItemInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__decimal);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__decimal, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
